from gstore_v3.models import Base, DBSession
from sqlalchemy import MetaData, Table, ForeignKey
from sqlalchemy import Column, String, Integer, Boolean, FetchedValue, TIMESTAMP, Numeric
from sqlalchemy.orm import relationship, backref
from sqlalchemy.sql.expression import and_

import os
from lxml import etree

from sqlalchemy.ext.declarative import declarative_base

from sqlalchemy.orm import (
    scoped_session,
    sessionmaker,
    )

from zope.sqlalchemy import ZopeTransactionExtension

from sqlalchemy.dialects.postgresql import UUID, ARRAY

from sqlalchemy.orm import relationship, backref

from ..lib.utils import *

'''

xslts identified as:

    resources/xslts/prov/{app_key}/{standard}_to_{ontology_key}_{format}.xslt

where:

    standard: input standard for the base file (ie iso ds)
    ontology_key: ontology used in the base file (elseweb modis v elseweb prism, etc)
    format: output format generated by xslt (ie rdf)

and these are stored in the mappings table
'''

class ProvBase(Base):
    __table__ = Table('provenance_bases', Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('uuid', UUID, FetchedValue()),
        Column('dataset_id', Integer, ForeignKey('gstoredata.datasets.id')),
        Column('ontology_id', Integer, ForeignKey('gstoredata.provenance_ontologies.id')), #this gives us app + ontology
        Column('inputstandards_id', Integer, ForeignKey('gstoredata.provenance_inputstandards.id')),
        Column('date_added', TIMESTAMP),
        Column('date_modified', TIMESTAMP),
        schema='gstoredata'
    )

    '''
    the link between a dataset, an app's ontology (elseweb + prism), and the dataset input file
    base files in {cache}/prov/{app_key}/{ontology_key}/{dataset uuid[0:2]}/{dataset uuid}_{standard}.{ext}


    NOTE: date_added/_modified should be set through the api (files on disk, no row-based trigger in place)
    '''

    def __repr__(self):
        return '<ProvBase (%s)>' % (self.id)

    def get_base(self, xml_cache_base):
        '''
        return the data
        '''

        #get the dataset uuid
        dataset_uuid = self.datasets.uuid

        #get the ontology key
        ontology_key = self.ontologies.ontology_key
        ontology_id = self.ontologies.id

        app = self.ontologies.prov_apps
        app_key = app.route_key
        
        #get the input standard and format
        input_standard = self.base_standards
        input_standard_key = input_standard.standard_key
        input_standard_format = input_standard.standard_format
        input_standard_id = input_standard.id

        xml_file = os.path.join(app_key, ontology_key, dataset_uuid[0:2], '%s_%s.%s' % (dataset_uuid, input_standard_key, input_standard_format))
        xml_path = os.path.join(xml_cache_base, xml_file)
        if not os.path.isfile(xml_path):
            raise Exception('no xml: %s' % xml_path)

        with open(xml_path, 'r') as f:
            output = f.read()

        return output    

    def transform_base(self, output_format, xslt_cache_base, xml_cache_base):
        '''
        get the file for the app+ontology+format
        get the xslt for the same (base = resources/xslts)

        transform
        '''

        #get the dataset uuid
        dataset_uuid = self.datasets.uuid

        #get the ontology key
        ontology_key = self.ontologies.ontology_key
        ontology_id = self.ontologies.id

        app = self.ontologies.prov_apps
        app_key = app.route_key
        

        #get the input standard and format
        input_standard = self.base_standards
        input_standard_key = input_standard.standard_key
        input_standard_format = input_standard.standard_format
        input_standard_id = input_standard.id

        #get the mapping
        mapping = DBSession.query(ProvMapping).filter(and_(ProvMapping.ontology_id==ontology_id, ProvMapping.inputstandards_id==input_standard_id, ProvMapping.output_format==output_format)).first()

        if mapping.transformation_method != 'xslt':
            raise Exception('not found')

        #TODO: how to handle anything that's not xslt?

        #get the xslt file
        xslt_file = mapping.transformation_file
        xslt_path = os.path.join(xslt_cache_base, app_key, xslt_file)
        if not os.path.isfile(xslt_path):
            raise Exception('no xslt: %s' % xslt_path)

        #get the input xml: ontology_key/dataset_uuid 2/uuid_standard.format
        xml_file = os.path.join(app_key, ontology_key, dataset_uuid[0:2], '%s_%s.%s' % (dataset_uuid, input_standard_key, input_standard_format))
        xml_path = os.path.join(xml_cache_base, xml_file)
        if not os.path.isfile(xml_path):
            raise Exception('no xml: %s' % xml_path)

        try:
            transformed = transform_xml_file(xml_path, xslt_path, {})
            return transformed
        except Exception as e:
            raise e

        return ''
      

class ProvOntology(Base):
    __table__ = Table('provenance_ontologies', Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('uuid', UUID, FetchedValue()),
        Column('ontology_key', String(20)),
        Column('ontology_name', String(100)),
        Column('app_id', Integer, ForeignKey('gstoredata.apps.id')),
        schema='gstoredata'        
    )
    '''
    supported ontologies

    note: must be specific to the base file, i.e. "elseweb" is not enough to id the modis structure
    '''

    prov_bases = relationship('ProvBase', backref='ontologies')

    def __repr__(self):
        return '<ProvOntology (%s)>' % (self.id)

class ProvMapping(Base):
    __table__ = Table('provenance_mappings', Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('ontology_id', Integer, ForeignKey('gstoredata.provenance_ontologies.id')),
        Column('inputstandards_id', Integer, ForeignKey('gstoredata.provenance_inputstandards.id')),
        Column('output_format', String(10)),
        Column('transformation_method', String(10)), #xslt, ?, ?
        Column('transformation_file', String(500)), #assuming it's an xslt on disk and this is the path in the pyramid app's resources
        schema='gstoredata'
    )
    '''
    we have an app (elseweb) with an ontology (modis) and need to get the transformation method/file
    for the input format + output format (ds xml -> rdf)

    and this is then assigned at the dataset level

    so:

        dataset x is part of elseweb
        elseweb has ontology a and ontology b
        ontology b has a transformation method for iso ds xml -> rdf
        dataset x has iso ds xml based on ontology b 

        the dataset can only have one input for the ontology + output method (modis + rdf == ds_to_modis.xslt)
        
        the request for dataset x via elseweb for ontology b as rdf returns the xslt-transformed ds as rdf xml

        mapping = elseweb + ontology b + input=iso ds + output=rdf for a given dataset

    this will be a problem later (yeah right, we'd need prov for some other reason)    


    note: ontology_id + inputstandards_id+output_format must be unique
    '''

    def __repr__(self):
        return '<ProvMapping (%s)>' % (self.id)


   


class ProvInputStandard(Base):
    __table__ = Table('provenance_inputstandards', Base.metadata,
        Column('id', Integer, primary_key=True),
        Column('standard_name', String(100)),
        Column('standard_key', String(20)),
        Column('standard_format', String(10)),
        schema='gstoredata'
    )

    '''
    define the supported inputs with the expected format

    so: iso ds as xml
    '''

    prov_mappings = relationship('ProvMapping', backref='mapping_standards')
    prov_bases = relationship('ProvBase', backref='base_standards')

    def __repr__(self):
        return '<ProvInputStandard (%s)>' % (self.id)















    
