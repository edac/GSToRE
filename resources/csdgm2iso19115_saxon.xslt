<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	FGDC CSDGM to ISO 19115-2 Transform using XPath 2.0

	This is the XML Style sheet that transforms metadata conforming to the Content Standards
	for Digital Geospatial Metadata of the Federal Geographic Data Committee June 1998 
	FGDC-STD-001-1999 version to the ISO 19115-2:2009(E).  This stylesheet can be applied
	to FGDC CSDGM XML to generate ISO 19115-2 XML.

	This file was generated by Altova MapForce 2009sp1

	Authors:
	This is the result of a collaboration of the Metadata Transform Working Group. 
	For further information, please contact NOAA's National Coastal Data 
	Development Center (NCDDC).
				National Coastal Data Development Center
				Toll Free: 866.732.2382
				E-mail: ncddcmetadata@noaa.gov

	Distribution liability:
		NOAA makes no warranty regarding these data, expressed or implied, 
		nor does the fact of distribution constitute such a warranty. NOAA, NESDIS, 
		NODC and NCDDC cannot assume liability for any damages caused by any 
		errors or omissions in these data, nor as a result of the failure of these data 
		to function on a particular system. These files were developed for opensource uses.

	Revisions:
		20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to "gmi:". 
		20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
		20100323 (JLM) Repeatability issues (repeating at characterString level instead
							 of attribute level) were fixed with grouping. Stratum Keyword 
							 thesauri and keywords were corrected. These elements were 
							 switched in the previous mappings. 'Unknown' was added as default
							 value to Spatial Rep. transformation parameter ability. 'Unknown' was 
							 added a default for mandatory fields that did not have content exist in
							 the FGDC source record. Extra spaces were removed from dates. 
		20100407 (JLM) Cleaned up the dates and also removed un-used elements.
		20100503 (JLM) Changed the MD_ root to MI_ to be more interoperable. Also added 
							 fileIdentifier.
		20100721 (JLM) Added Extent ids.
		20100811 (JLM) Removed mapping of onlink linkage to datasetURI, instead mapped to 
							 Dist Info linkage URL. 
		20100223 (JLM) Corrected for error not mapping otherConstraints. Corrected error to
							 repeat at gmd:distributionFormat instead of name and version. Changed 
							 language from 'eng' to 'eng; USA'. Corrected ISO name and version. 
							 Made allowances for srcscal = "unknown". 
-->
<xsl:stylesheet version="2.0" saxon:allow-all-built-in-types="yes" xmlns:saxon="http://saxon.sf.net/" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmi="http://www.isotc211.org/2005/gmi" xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss" xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml/3.2" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:grp="http://www.altova.com/Mapforce/grouping" exclude-result-prefixes="fn grp vmf xs xsi xsl" xmlns="http://www.isotc211.org/2005/gmi">
	<xsl:template name="vmf:vmf1_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf2_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf3_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf4_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf5_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf6_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf7_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf8_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf9_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf10_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf11_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf12_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf13_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf14_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input='RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf15_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf16_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf17_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input='3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input='3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input='3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input='4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input='1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input='DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input='ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input='SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input='TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input='HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input='CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input='CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf18_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf19_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input='TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input='HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input='ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>
	<xsl:function name="grp:key170c56f8">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/browsen">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key18fdb8d8">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekt">
			<xsl:if test="not(fn:contains(xs:string(xs:string(.)), 'ISO 19115'))">
				<xsl:sequence select="xs:string(xs:string(.))"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19a0ab58">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/themekey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19fdc708">
		<xsl:param name="cur"/>
		<xsl:for-each-group select="$cur" group-by="grp:key19a0ab58(.)">
			<xsl:variable name="var460_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
			<xsl:sequence select="fn:normalize-space($var460_cur_result_groupby)"/>
		</xsl:for-each-group>
	</xsl:function>
	<xsl:function name="grp:key18920260">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekt">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key17313240">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/placekey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19eccad8">
		<xsl:param name="cur"/>
		<xsl:for-each-group select="$cur" group-by="grp:key17313240(.)">
			<xsl:variable name="var476_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
			<xsl:sequence select="fn:normalize-space($var476_cur_result_groupby)"/>
		</xsl:for-each-group>
	</xsl:function>
	<xsl:function name="grp:key156aa088">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkt">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key18408680">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/stratkey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19fea208">
		<xsl:param name="cur"/>
		<xsl:for-each-group select="$cur" group-by="grp:key18408680(.)">
			<xsl:variable name="var492_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
			<xsl:sequence select="fn:normalize-space($var492_cur_result_groupby)"/>
		</xsl:for-each-group>
	</xsl:function>
	<xsl:function name="grp:key0d62a468">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkt">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key14f75588">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/tempkey">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19b11470">
		<xsl:param name="cur"/>
		<xsl:for-each-group select="$cur" group-by="grp:key14f75588(.)">
			<xsl:variable name="var508_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
			<xsl:sequence select="fn:normalize-space($var508_cur_result_groupby)"/>
		</xsl:for-each-group>
	</xsl:function>
	<xsl:function name="grp:key1a17d0b8">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/offmedia">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key19e65b10">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:sequence select="xs:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key18d59618">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:key197eca10">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/caldate">
			<xsl:sequence select="xs:string(xs:string(.))"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:template match="/">
		<gmi:MI_Metadata>
			<xsl:attribute name="xsi:schemaLocation" separator=" ">
				<xsl:sequence select="'http://www.isotc211.org/2005/gmi Q:/users/mize.jacqueline/ISO/gmi/gmi.xsd'"/>
			</xsl:attribute>
			<xsl:variable name="var1_instance" as="node()" select="."/>
			<gmd:fileIdentifier>
				<xsl:for-each select="$var1_instance/metadata">
					<gco:CharacterString>
						<xsl:sequence select="fn:concat('gov.noaa.nodc.ncddc.', fn:substring-before(fn:base-uri(.), '.xml'))"/>
					</gco:CharacterString>
				</xsl:for-each>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>
					<xsl:sequence select="'eng; USA'"/>
				</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('utf8'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
					</xsl:attribute>
					<xsl:sequence select="'utf8'"/>
				</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode>
					<xsl:attribute name="codeList">
						<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:sequence select="xs:string(xs:anyURI('dataset'))"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
					</xsl:attribute>
					<xsl:sequence select="'dataset'"/>
				</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<xsl:variable name="var7_map_select_metadata" as="xs:string*">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var4_cond_result_exists" as="xs:string*">
						<xsl:choose>
							<xsl:when test="fn:exists($var7_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:for-each select="$var4_cond_result_exists">
						<gmd:individualName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(.)"/>
							</gco:CharacterString>
						</gmd:individualName>
					</xsl:for-each>
					<xsl:variable name="var18_map_select_metadata" as="xs:string*">
						<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
							<xsl:sequence select="xs:string(.)"/>
						</xsl:for-each>
					</xsl:variable>
					<xsl:variable name="var15_cond_result_exists" as="xs:string*">
						<xsl:choose>
							<xsl:when test="fn:exists($var18_map_select_metadata)">
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:when>
							<xsl:otherwise>
								<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
									<xsl:sequence select="xs:string(.)"/>
								</xsl:for-each>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:for-each select="$var15_cond_result_exists">
						<gmd:organisationName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(.)"/>
							</gco:CharacterString>
						</gmd:organisationName>
					</xsl:for-each>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
							</gco:CharacterString>
						</gmd:positionName>
					</xsl:for-each>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<gmd:phone>
								<gmd:CI_Telephone>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var30_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:voice>
											<gco:CharacterString>
												<xsl:sequence select="$var30_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:voice>
									</xsl:for-each-group>
									<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
										<xsl:variable name="var34_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
										<gmd:facsimile>
											<gco:CharacterString>
												<xsl:sequence select="$var34_cur_result_groupby"/>
											</gco:CharacterString>
										</gmd:facsimile>
									</xsl:for-each-group>
								</gmd:CI_Telephone>
							</gmd:phone>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo">
								<xsl:variable name="var36_cntinfo" as="node()" select="."/>
								<xsl:for-each select="cntaddr">
									<gmd:address>
										<gmd:CI_Address>
											<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var42_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:deliveryPoint>
													<gco:CharacterString>
														<xsl:sequence select="$var42_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:deliveryPoint>
											</xsl:for-each-group>
											<xsl:for-each select="city">
												<gmd:city>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:city>
											</xsl:for-each>
											<xsl:for-each select="state">
												<gmd:administrativeArea>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:administrativeArea>
											</xsl:for-each>
											<xsl:for-each select="postal">
												<gmd:postalCode>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:postalCode>
											</xsl:for-each>
											<xsl:for-each select="country">
												<gmd:country>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:country>
											</xsl:for-each>
											<xsl:for-each-group select="$var36_cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var54_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:electronicMailAddress>
													<gco:CharacterString>
														<xsl:sequence select="$var54_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:electronicMailAddress>
											</xsl:for-each-group>
										</gmd:CI_Address>
									</gmd:address>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
								<gmd:hoursOfService>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:hoursOfService>
							</xsl:for-each>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
								<gmd:contactInstructions>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:contactInstructions>
							</xsl:for-each>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<gmd:role>
						<gmd:CI_RoleCode>
							<xsl:attribute name="codeList">
								<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeListValue">
								<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
							</xsl:attribute>
							<xsl:attribute name="codeSpace">
								<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
							</xsl:attribute>
							<xsl:sequence select="'pointOfContact'"/>
						</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:for-each select="$var1_instance/metadata/metainfo/metd">
					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished'))">
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(fn:string(.)))))"/>
						</xsl:attribute>
					</xsl:if>
				</xsl:for-each>
				<xsl:for-each select="$var1_instance/metadata/metainfo/metd">
					<xsl:variable name="var65_cond_result_logicalor" as="xs:string?">
						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present')))">
							<xsl:variable name="var70_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(fn:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(fn:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
									<xsl:choose>
										<xsl:when test="fn:ends-with(., '-')">
											<xsl:if test="fn:ends-with(., '-')">
												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
												</xsl:if>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="."/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:for-each>
							</xsl:variable>
							<xsl:variable name="var69_map_result_distinctvalues" as="xs:string*">
								<xsl:for-each select="fn:distinct-values($var70_map_result_distinctvalues)">
									<xsl:variable name="var75_cond_result_endswith" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
													</xsl:if>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:if test="fn:exists($var75_cond_result_endswith)">
										<xsl:sequence select="$var75_cond_result_endswith"/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:exists($var69_map_result_distinctvalues)">
								<xsl:sequence select="xs:string(fn:string-join($var69_map_result_distinctvalues, ' '))"/>
							</xsl:if>
						</xsl:if>
					</xsl:variable>
					<xsl:for-each select="$var65_cond_result_logicalor">
						<gco:Date>
							<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
						</gco:Date>
					</xsl:for-each>
				</xsl:for-each>
			</gmd:dateStamp>
			<gmd:metadataStandardName>
				<gco:CharacterString>
					<xsl:sequence select="'ISO 19115-2'"/>
				</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>
					<xsl:sequence select="'2009-02-15'"/>
				</gco:CharacterString>
			</gmd:metadataStandardVersion>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var82_metadata" as="node()" select="."/>
				<xsl:for-each select="spdoinfo">
					<gmd:spatialRepresentationInfo>
						<xsl:for-each select="rastinfo">
							<xsl:variable name="var86_rastinfo" as="node()" select="."/>
							<gmd:MD_GridSpatialRepresentation>
								<gmd:numberOfDimensions>
									<xsl:variable name="var88_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(rowcount)) then xs:decimal(1) else ())"/>
									<xsl:if test="fn:exists($var88_cond_result_exists)">
										<xsl:variable name="var89_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(colcount)) then xs:decimal(1) else ())"/>
										<xsl:if test="fn:exists($var89_cond_result_exists)">
											<xsl:variable name="var90_cond_result_exists" as="xs:decimal?" select="(if (fn:exists(vrtcount)) then xs:decimal(1) else ())"/>
											<xsl:if test="fn:exists($var90_cond_result_exists)">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer((($var88_cond_result_exists + $var89_cond_result_exists) + $var90_cond_result_exists)))"/>
												</gco:Integer>
											</xsl:if>
										</xsl:if>
									</xsl:if>
								</gmd:numberOfDimensions>
								<xsl:for-each select="$var82_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var93_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/rowcount)) then 'row' else ())"/>
												<xsl:if test="fn:exists($var93_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var94_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/rowcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var94_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var94_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var93_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var95_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/rowcount)) then '001' else ())"/>
														<xsl:if test="fn:exists($var95_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var95_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var93_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var86_rastinfo/rowcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var82_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var100_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/colcount)) then 'column' else ())"/>
												<xsl:if test="fn:exists($var100_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var101_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/colcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var101_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var101_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var100_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var102_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/colcount)) then '002' else ())"/>
														<xsl:if test="fn:exists($var102_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var102_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var100_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var86_rastinfo/colcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<xsl:for-each select="$var82_metadata/idinfo/citation/citeinfo/lworkcit">
									<gmd:axisDimensionProperties>
										<gmd:MD_Dimension>
											<gmd:dimensionName>
												<xsl:variable name="var107_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/vrtcount)) then 'vertical' else ())"/>
												<xsl:if test="fn:exists($var107_cond_result_exists)">
													<gmd:MD_DimensionNameTypeCode>
														<xsl:variable name="var108_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/vrtcount)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode' else ())"/>
														<xsl:if test="fn:exists($var108_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var108_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI($var107_cond_result_exists))"/>
														</xsl:attribute>
														<xsl:variable name="var109_cond_result_exists" as="xs:string?" select="(if (fn:exists($var86_rastinfo/vrtcount)) then '003' else ())"/>
														<xsl:if test="fn:exists($var109_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var109_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="$var107_cond_result_exists"/>
													</gmd:MD_DimensionNameTypeCode>
												</xsl:if>
											</gmd:dimensionName>
											<gmd:dimensionSize>
												<xsl:for-each select="$var86_rastinfo/vrtcount">
													<gco:Integer>
														<xsl:sequence select="xs:string(xs:integer(xs:positiveInteger(.)))"/>
													</gco:Integer>
												</xsl:for-each>
											</gmd:dimensionSize>
										</gmd:MD_Dimension>
									</gmd:axisDimensionProperties>
								</xsl:for-each>
								<gmd:cellGeometry>
									<xsl:variable name="var130_map_select_rasttype" as="xs:string*">
										<xsl:for-each select="rasttype">
											<xsl:sequence select="fn:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var112_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var130_map_select_rasttype)">
												<xsl:variable name="var132_map_select_rasttype" as="xs:string*">
													<xsl:for-each select="rasttype">
														<xsl:variable name="var135_result_vmf1_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf1_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:if test="fn:exists($var135_result_vmf1_inputtoresult)">
															<xsl:sequence select="$var135_result_vmf1_inputtoresult"/>
														</xsl:if>
													</xsl:for-each>
												</xsl:variable>
												<xsl:if test="fn:exists($var132_map_select_rasttype)">
													<xsl:sequence select="xs:string(fn:string-join($var132_map_select_rasttype, ' '))"/>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="''"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var112_cond_result_exists">
										<gmd:MD_CellGeometryCode>
											<xsl:attribute name="codeList">
												<xsl:variable name="var116_map_select_rasttype" as="xs:string*">
													<xsl:for-each select="$var86_rastinfo/rasttype">
														<xsl:sequence select="fn:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var115_cond_result_exists" as="xs:string" select="(if (fn:exists($var116_map_select_rasttype)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode' else '')"/>
												<xsl:sequence select="xs:string(xs:anyURI($var115_cond_result_exists))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI(.))"/>
											</xsl:attribute>
											<xsl:variable name="var122_map_select_rasttype" as="xs:string*">
												<xsl:for-each select="$var86_rastinfo/rasttype">
													<xsl:sequence select="fn:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var119_cond_result_exists" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:exists($var122_map_select_rasttype)">
														<xsl:variable name="var124_map_select_rasttype" as="xs:string*">
															<xsl:for-each select="$var86_rastinfo/rasttype">
																<xsl:variable name="var127_result_vmf2_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf2_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:if test="fn:exists($var127_result_vmf2_inputtoresult)">
																	<xsl:sequence select="$var127_result_vmf2_inputtoresult"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:variable>
														<xsl:if test="fn:exists($var124_map_select_rasttype)">
															<xsl:sequence select="xs:string(fn:string-join($var124_map_select_rasttype, ' '))"/>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="''"/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var119_cond_result_exists">
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI(.))"/>
												</xsl:attribute>
											</xsl:for-each>
											<xsl:sequence select="."/>
										</gmd:MD_CellGeometryCode>
									</xsl:for-each>
								</gmd:cellGeometry>
								<gmd:transformationParameterAvailability>
									<xsl:variable name="var138_cond_result_exists" as="xs:string?" select="(if (fn:exists(rowcount)) then 'unknown' else ())"/>
									<xsl:if test="fn:exists($var138_cond_result_exists)">
										<xsl:attribute name="gco:nilReason">
											<xsl:sequence select="xs:string(xs:string($var138_cond_result_exists))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:transformationParameterAvailability>
							</gmd:MD_GridSpatialRepresentation>
						</xsl:for-each>
						<xsl:for-each select="ptvctinf">
							<xsl:variable name="var139_ptvctinf" as="node()" select="."/>
							<gmd:MD_VectorSpatialRepresentation>
								<xsl:for-each select="vpfterm/vpflevel">
									<gmd:topologyLevel>
										<gmd:MD_TopologyLevelCode>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(fn:string(.))))"/>
											</xsl:attribute>
										</gmd:MD_TopologyLevelCode>
									</gmd:topologyLevel>
								</xsl:for-each>
								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<xsl:variable name="var167_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm/sdtstype">
													<xsl:sequence select="fn:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var143_cond_result_exists" as="xs:string?">
												<xsl:if test="fn:exists($var167_map_select_sdtsterm)">
													<xsl:variable name="var169_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var167_map_select_sdtsterm)">
																<xsl:variable name="var175_map_select_sdtsterm" as="xs:string*">
																	<xsl:for-each select="sdtsterm/sdtstype">
																		<xsl:if test="fn:exists($var167_map_select_sdtsterm)">
																			<xsl:sequence select="fn:string(.)"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var175_map_select_sdtsterm)">
																	<xsl:sequence select="xs:string(fn:string-join($var175_map_select_sdtsterm, ' '))"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:variable name="var178_map_select_vpfterm" as="xs:string*">
																	<xsl:for-each select="vpfterm/vpflevel">
																		<xsl:sequence select="fn:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var178_map_select_vpfterm)">
																	<xsl:sequence select="xs:string(fn:string-join($var178_map_select_vpfterm, ' '))"/>
																</xsl:if>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var169_cond_result_exists">
														<xsl:variable name="var172_result_vmf3_inputtoresult" as="xs:string?">
															<xsl:call-template name="vmf:vmf3_inputtoresult">
																<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
															</xsl:call-template>
														</xsl:variable>
														<xsl:sequence select="$var172_result_vmf3_inputtoresult"/>
													</xsl:for-each>
												</xsl:if>
											</xsl:variable>
											<xsl:if test="fn:exists($var143_cond_result_exists)">
												<gmd:MD_GeometricObjectTypeCode>
													<xsl:variable name="var144_map_select_vpfterm" as="xs:string*">
														<xsl:for-each select="vpfterm/vpflevel">
															<xsl:sequence select="fn:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var145_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm/sdtstype">
															<xsl:sequence select="fn:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists((if ((fn:exists($var145_map_select_sdtsterm) or fn:exists($var144_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string((if ((fn:exists($var145_map_select_sdtsterm) or fn:exists($var144_map_select_vpfterm))) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode' else ()))))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(fn:string($var143_cond_result_exists)))"/>
													</xsl:attribute>
													<xsl:variable name="var151_map_select_sdtsterm" as="xs:string*">
														<xsl:for-each select="sdtsterm/sdtstype">
															<xsl:sequence select="fn:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var150_cond_result_exists" as="xs:string?">
														<xsl:if test="fn:exists($var151_map_select_sdtsterm)">
															<xsl:variable name="var153_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var151_map_select_sdtsterm)">
																		<xsl:variable name="var159_map_select_sdtsterm" as="xs:string*">
																			<xsl:for-each select="sdtsterm/sdtstype">
																				<xsl:if test="fn:exists($var151_map_select_sdtsterm)">
																					<xsl:sequence select="fn:string(.)"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var159_map_select_sdtsterm)">
																			<xsl:sequence select="xs:string(fn:string-join($var159_map_select_sdtsterm, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:variable name="var162_map_select_vpfterm" as="xs:string*">
																			<xsl:for-each select="vpfterm/vpflevel">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var162_map_select_vpfterm)">
																			<xsl:sequence select="xs:string(fn:string-join($var162_map_select_vpfterm, ' '))"/>
																		</xsl:if>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var153_cond_result_exists">
																<xsl:variable name="var156_result_vmf4_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf4_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:sequence select="$var156_result_vmf4_inputtoresult"/>
															</xsl:for-each>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var150_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(fn:string($var150_cond_result_exists)))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="fn:string($var143_cond_result_exists)"/>
												</gmd:MD_GeometricObjectTypeCode>
											</xsl:if>
										</gmd:geometricObjectType>
										<gmd:geometricObjectCount>
											<xsl:variable name="var186_map_select_sdtsterm" as="xs:string*">
												<xsl:for-each select="sdtsterm/ptvctcnt">
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var183_cond_result_exists" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists($var186_map_select_sdtsterm)">
														<xsl:for-each select="sdtsterm/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="vpfterm/vpfinfo/ptvctcnt">
															<xsl:sequence select="xs:string(xs:integer(.))"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var183_cond_result_exists">
												<gco:Integer>
													<xsl:sequence select="xs:string(xs:integer(.))"/>
												</gco:Integer>
											</xsl:for-each>
										</gmd:geometricObjectCount>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
							</gmd:MD_VectorSpatialRepresentation>
						</xsl:for-each>
					</gmd:spatialRepresentationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/spdoinfo">
				<gmd:referenceSystemInfo>
					<gmd:MD_ReferenceSystem>
						<xsl:for-each select="indspref">
							<gmd:referenceSystemIdentifier>
								<gmd:RS_Identifier>
									<gmd:codeSpace>
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</gmd:codeSpace>
								</gmd:RS_Identifier>
							</gmd:referenceSystemIdentifier>
						</xsl:for-each>
					</gmd:MD_ReferenceSystem>
				</gmd:referenceSystemInfo>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/metainfo/metextns">
				<gmd:metadataExtensionInfo>
					<gmd:MD_MetadataExtensionInformation>
						<gmd:extensionOnLineResource>
							<gmd:CI_OnlineResource>
								<xsl:for-each select="onlink">
									<gmd:linkage>
										<gmd:URL>
											<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
										</gmd:URL>
									</gmd:linkage>
								</xsl:for-each>
								<xsl:for-each select="metprof">
									<gmd:name>
										<gco:CharacterString>
											<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
										</gco:CharacterString>
									</gmd:name>
								</xsl:for-each>
							</gmd:CI_OnlineResource>
						</gmd:extensionOnLineResource>
					</gmd:MD_MetadataExtensionInformation>
				</gmd:metadataExtensionInfo>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var204_metadata" as="node()" select="."/>
				<xsl:for-each select="idinfo">
					<xsl:variable name="var206_idinfo" as="node()" select="."/>
					<gmd:identificationInfo>
						<gmd:MD_DataIdentification>
							<xsl:for-each select="citation">
								<gmd:citation>
									<xsl:for-each select="citeinfo">
										<xsl:variable name="var210_citeinfo" as="node()" select="."/>
										<gmd:CI_Citation>
											<gmd:title>
												<xsl:for-each select="title">
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:title>
											<gmd:date>
												<gmd:CI_Date>
													<gmd:date>
														<xsl:for-each select="pubdate">
															<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																<xsl:attribute name="gco:nilReason">
																	<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																</xsl:attribute>
															</xsl:if>
														</xsl:for-each>
														<xsl:for-each select="pubdate">
															<xsl:variable name="var219_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																	<xsl:variable name="var224_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var223_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var224_map_result_distinctvalues)">
																			<xsl:variable name="var229_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var229_cond_result_endswith)">
																				<xsl:sequence select="$var229_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var223_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var223_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var219_cond_result_logicalor">
																<gco:Date>
																	<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																</gco:Date>
															</xsl:for-each>
														</xsl:for-each>
														<xsl:for-each select="pubdate">
															<xsl:variable name="var239_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																	<xsl:variable name="var272_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var271_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var272_map_result_distinctvalues)">
																			<xsl:variable name="var277_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var277_cond_result_endswith)">
																				<xsl:sequence select="$var277_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var271_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var271_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var239_cond_result_logicalor">
																<xsl:variable name="var240_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var242_map_select_pubtime" as="xs:string*">
																	<xsl:for-each select="$var210_citeinfo/pubtime">
																		<xsl:variable name="var269_result_vmf5_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf5_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var268_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var269_result_vmf5_inputtoresult)) then (if (fn:contains($var269_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var268_cond_result_exists))">
																			<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var242_map_select_pubtime)">
																	<xsl:variable name="var247_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var247_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var247_cond_result_endswith)), 'Un'))">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var247_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var247_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var247_cond_result_endswith))))) then 'T' else ()))">
																				<gco:DateTime>
																					<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var240_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var247_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var247_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var247_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var247_cond_result_endswith))))))"/>
																				</gco:DateTime>
																			</xsl:if>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:date>
													<gmd:dateType>
														<xsl:variable name="var284_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'publication' else ())"/>
														<xsl:if test="fn:exists($var284_cond_result_exists)">
															<gmd:CI_DateTypeCode>
																<xsl:variable name="var285_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																<xsl:if test="fn:exists($var285_cond_result_exists)">
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI($var285_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI($var284_cond_result_exists))"/>
																</xsl:attribute>
																<xsl:variable name="var286_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then '002' else ())"/>
																<xsl:if test="fn:exists($var286_cond_result_exists)">
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI($var286_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:sequence select="$var284_cond_result_exists"/>
															</gmd:CI_DateTypeCode>
														</xsl:if>
													</gmd:dateType>
												</gmd:CI_Date>
											</gmd:date>
											<xsl:for-each select="edition">
												<gmd:edition>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:edition>
											</xsl:for-each>
											<xsl:for-each select="$var204_metadata/distinfo/resdesc">
												<gmd:identifier>
													<gmd:MD_Identifier>
														<gmd:code>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:code>
													</gmd:MD_Identifier>
												</gmd:identifier>
											</xsl:for-each>
											<xsl:for-each-group select="origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
												<xsl:variable name="var293_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:citedResponsibleParty>
													<gmd:CI_ResponsibleParty>
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="$var293_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:organisationName>
														<gmd:role>
															<gmd:CI_RoleCode>
																<xsl:attribute name="codeList">
																	<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																</xsl:attribute>
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																</xsl:attribute>
																<xsl:sequence select="'originator'"/>
															</gmd:CI_RoleCode>
														</gmd:role>
													</gmd:CI_ResponsibleParty>
												</gmd:citedResponsibleParty>
											</xsl:for-each-group>
											<gmd:presentationForm>
												<xsl:variable name="var295_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="$var210_citeinfo/geoform">
															<xsl:variable name="var309_map_select_geoform" as="xs:string*">
																<xsl:for-each select="geoform">
																	<xsl:variable name="var312_result_vmf6_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf6_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var312_result_vmf6_inputtoresult)">
																		<xsl:sequence select="$var312_result_vmf6_inputtoresult"/>
																	</xsl:if>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var309_map_select_geoform)">
																<xsl:sequence select="xs:string(fn:string-join($var309_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:variable name="var313_map_select_geoform" as="xs:string*">
																<xsl:for-each select="geoform">
																	<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var313_map_select_geoform)">
																<xsl:sequence select="xs:string(fn:string-join($var313_map_select_geoform, ' '))"/>
															</xsl:if>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var295_cond_result_exists">
													<gmd:CI_PresentationFormCode>
														<xsl:variable name="var298_cond_result_exists" as="xs:string?" select="(if (fn:exists($var210_citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
														<xsl:if test="fn:exists($var298_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var298_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:attribute name="codeListValue">
															<xsl:sequence select="xs:string(xs:anyURI(.))"/>
														</xsl:attribute>
														<xsl:variable name="var299_cond_result_exists" as="xs:string?">
															<xsl:if test="$var210_citeinfo/geoform">
																<xsl:variable name="var303_map_select_geoform" as="xs:string*">
																	<xsl:for-each select="$var210_citeinfo/geoform">
																		<xsl:variable name="var306_result_vmf7_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf7_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var306_result_vmf7_inputtoresult)">
																			<xsl:sequence select="$var306_result_vmf7_inputtoresult"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var303_map_select_geoform)">
																	<xsl:sequence select="xs:string(fn:string-join($var303_map_select_geoform, ' '))"/>
																</xsl:if>
															</xsl:if>
														</xsl:variable>
														<xsl:for-each select="$var299_cond_result_exists">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI(.))"/>
															</xsl:attribute>
														</xsl:for-each>
														<xsl:sequence select="."/>
													</gmd:CI_PresentationFormCode>
												</xsl:for-each>
											</gmd:presentationForm>
											<xsl:for-each select="serinfo">
												<gmd:series>
													<gmd:CI_Series>
														<gmd:name>
															<xsl:for-each select="sername">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:name>
														<gmd:issueIdentification>
															<xsl:for-each select="issue">
																<gco:CharacterString>
																	<xsl:sequence select="xs:string(.)"/>
																</gco:CharacterString>
															</xsl:for-each>
														</gmd:issueIdentification>
													</gmd:CI_Series>
												</gmd:series>
											</xsl:for-each>
											<xsl:for-each select="othercit">
												<gmd:otherCitationDetails>
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</gmd:otherCitationDetails>
											</xsl:for-each>
										</gmd:CI_Citation>
									</xsl:for-each>
								</gmd:citation>
							</xsl:for-each>
							<xsl:for-each select="descript/abstract">
								<gmd:abstract>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:abstract>
							</xsl:for-each>
							<xsl:for-each select="descript/purpose">
								<gmd:purpose>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:purpose>
							</xsl:for-each>
							<xsl:for-each-group select="datacred" group-by="fn:normalize-space(xs:string(.))">
								<xsl:variable name="var330_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
								<gmd:credit>
									<gco:CharacterString>
										<xsl:sequence select="$var330_cur_result_groupby"/>
									</gco:CharacterString>
								</gmd:credit>
							</xsl:for-each-group>
							<gmd:status>
								<xsl:variable name="var350_map_select_status" as="xs:string*">
									<xsl:for-each select="status/progress">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var332_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="fn:exists($var350_map_select_status)">
											<xsl:variable name="var352_map_select_status" as="xs:string*">
												<xsl:for-each select="status/progress">
													<xsl:variable name="var355_result_vmf8_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf8_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:if test="fn:exists($var355_result_vmf8_inputtoresult)">
														<xsl:sequence select="$var355_result_vmf8_inputtoresult"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var352_map_select_status)">
												<xsl:sequence select="xs:string(fn:string-join($var352_map_select_status, ' '))"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="''"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var332_cond_result_exists">
									<gmd:MD_ProgressCode>
										<xsl:attribute name="codeList">
											<xsl:variable name="var336_map_select_status" as="xs:string*">
												<xsl:for-each select="$var206_idinfo/status/progress">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var335_cond_result_exists" as="xs:string" select="(if (fn:exists($var336_map_select_status)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/>
											<xsl:sequence select="xs:string(xs:anyURI($var335_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI(.))"/>
										</xsl:attribute>
										<xsl:variable name="var342_map_select_status" as="xs:string*">
											<xsl:for-each select="$var206_idinfo/status/progress">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var339_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists($var342_map_select_status)">
													<xsl:variable name="var344_map_select_status" as="xs:string*">
														<xsl:for-each select="$var206_idinfo/status/progress">
															<xsl:variable name="var347_result_vmf9_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf9_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var347_result_vmf9_inputtoresult)">
																<xsl:sequence select="$var347_result_vmf9_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var344_map_select_status)">
														<xsl:sequence select="xs:string(fn:string-join($var344_map_select_status, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var339_cond_result_exists">
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI(.))"/>
											</xsl:attribute>
										</xsl:for-each>
										<xsl:sequence select="."/>
									</gmd:MD_ProgressCode>
								</xsl:for-each>
							</gmd:status>
							<xsl:for-each select="ptcontac">
								<gmd:pointOfContact>
									<xsl:for-each select="cntinfo">
										<xsl:variable name="var360_cntinfo" as="node()" select="."/>
										<gmd:CI_ResponsibleParty>
											<xsl:variable name="var365_map_select_cntperp" as="xs:string*">
												<xsl:for-each select="cntperp/cntper">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var362_cond_result_exists" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists($var365_map_select_cntperp)">
														<xsl:for-each select="cntperp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var362_cond_result_exists">
												<gmd:individualName>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(.)"/>
													</gco:CharacterString>
												</gmd:individualName>
											</xsl:for-each>
											<xsl:variable name="var376_map_select_cntperp" as="xs:string*">
												<xsl:for-each select="cntperp/cntorg">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var373_cond_result_exists" as="xs:string*">
												<xsl:choose>
													<xsl:when test="fn:exists($var376_map_select_cntperp)">
														<xsl:for-each select="cntperp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:when>
													<xsl:otherwise>
														<xsl:for-each select="cntorgp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var373_cond_result_exists">
												<gmd:organisationName>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(.)"/>
													</gco:CharacterString>
												</gmd:organisationName>
											</xsl:for-each>
											<xsl:for-each select="cntpos">
												<gmd:positionName>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
													</gco:CharacterString>
												</gmd:positionName>
											</xsl:for-each>
											<gmd:contactInfo>
												<gmd:CI_Contact>
													<gmd:phone>
														<gmd:CI_Telephone>
															<xsl:for-each-group select="cntvoice" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var388_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:voice>
																	<gco:CharacterString>
																		<xsl:sequence select="$var388_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:voice>
															</xsl:for-each-group>
															<xsl:for-each-group select="cntfax" group-by="fn:normalize-space(xs:string(.))">
																<xsl:variable name="var392_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:facsimile>
																	<gco:CharacterString>
																		<xsl:sequence select="$var392_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:facsimile>
															</xsl:for-each-group>
														</gmd:CI_Telephone>
													</gmd:phone>
													<gmd:address>
														<xsl:for-each select="$var204_metadata/metainfo/metc/cntinfo/cntaddr">
															<gmd:CI_Address>
																<xsl:for-each-group select="$var360_cntinfo/cntaddr/address" group-by="fn:normalize-space(xs:string(.))">
																	<xsl:variable name="var398_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																	<gmd:deliveryPoint>
																		<gco:CharacterString>
																			<xsl:sequence select="$var398_cur_result_groupby"/>
																		</gco:CharacterString>
																	</gmd:deliveryPoint>
																</xsl:for-each-group>
																<xsl:for-each select="$var360_cntinfo/cntaddr/city">
																	<gmd:city>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:city>
																</xsl:for-each>
																<xsl:for-each select="$var360_cntinfo/cntaddr/state">
																	<gmd:administrativeArea>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:administrativeArea>
																</xsl:for-each>
																<xsl:for-each select="$var360_cntinfo/cntaddr/postal">
																	<gmd:postalCode>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:postalCode>
																</xsl:for-each>
																<xsl:for-each select="$var360_cntinfo/cntaddr/country">
																	<gmd:country>
																		<gco:CharacterString>
																			<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																		</gco:CharacterString>
																	</gmd:country>
																</xsl:for-each>
																<xsl:for-each-group select="$var360_cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																	<xsl:variable name="var410_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																	<gmd:electronicMailAddress>
																		<gco:CharacterString>
																			<xsl:sequence select="$var410_cur_result_groupby"/>
																		</gco:CharacterString>
																	</gmd:electronicMailAddress>
																</xsl:for-each-group>
															</gmd:CI_Address>
														</xsl:for-each>
													</gmd:address>
													<xsl:for-each select="hours">
														<gmd:hoursOfService>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:hoursOfService>
													</xsl:for-each>
													<xsl:for-each select="cntinst">
														<gmd:contactInstructions>
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</gmd:contactInstructions>
													</xsl:for-each>
												</gmd:CI_Contact>
											</gmd:contactInfo>
											<gmd:role>
												<gmd:CI_RoleCode>
													<xsl:attribute name="codeList">
														<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI('pointOfContact'))"/>
													</xsl:attribute>
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI('007'))"/>
													</xsl:attribute>
													<xsl:sequence select="'pointOfContact'"/>
												</gmd:CI_RoleCode>
											</gmd:role>
										</gmd:CI_ResponsibleParty>
									</xsl:for-each>
								</gmd:pointOfContact>
							</xsl:for-each>
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var416_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="fn:exists(status/update)">
													<xsl:variable name="var429_map_select_status" as="xs:string*">
														<xsl:for-each select="status/update">
															<xsl:variable name="var432_result_vmf10_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf10_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:sequence select="$var432_result_vmf10_inputtoresult"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var429_map_select_status)">
														<xsl:sequence select="xs:string(fn:string-join($var429_map_select_status, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var416_cond_result_exists">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:variable name="var419_cond_result_exists" as="xs:string" select="(if (fn:exists($var206_idinfo/status/update)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode' else '')"/>
													<xsl:sequence select="xs:string(xs:anyURI($var419_cond_result_exists))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI(.))"/>
												</xsl:attribute>
												<xsl:variable name="var420_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="fn:exists($var206_idinfo/status/update)">
															<xsl:variable name="var424_map_select_status" as="xs:string*">
																<xsl:for-each select="$var206_idinfo/status/update">
																	<xsl:variable name="var427_result_vmf11_inputtoresult" as="xs:string?">
																		<xsl:call-template name="vmf:vmf11_inputtoresult">
																			<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																		</xsl:call-template>
																	</xsl:variable>
																	<xsl:sequence select="$var427_result_vmf11_inputtoresult"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var424_map_select_status)">
																<xsl:sequence select="xs:string(fn:string-join($var424_map_select_status, ' '))"/>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="''"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var420_cond_result_exists">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI(.))"/>
													</xsl:attribute>
												</xsl:for-each>
												<xsl:sequence select="."/>
											</gmd:MD_MaintenanceFrequencyCode>
										</xsl:for-each>
									</gmd:maintenanceAndUpdateFrequency>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
							<gmd:resourceMaintenance>
								<xsl:for-each select="$var204_metadata/eainfo/detailed/attr/attrmfrq">
									<gmd:MD_MaintenanceInformation>
										<gmd:maintenanceAndUpdateFrequency>
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:variable name="var435_result_vmf10_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf10_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:sequence select="xs:string(xs:anyURI($var435_result_vmf10_inputtoresult))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:variable name="var436_result_vmf11_inputtoresult" as="xs:string?">
														<xsl:call-template name="vmf:vmf11_inputtoresult">
															<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
														</xsl:call-template>
													</xsl:variable>
													<xsl:sequence select="xs:string(xs:anyURI($var436_result_vmf11_inputtoresult))"/>
												</xsl:attribute>
												<xsl:variable name="var437_result_vmf10_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf10_inputtoresult">
														<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:sequence select="$var437_result_vmf10_inputtoresult"/>
											</gmd:MD_MaintenanceFrequencyCode>
										</gmd:maintenanceAndUpdateFrequency>
										<gmd:updateScope>
											<gmd:MD_ScopeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('attribute'))"/>
												</xsl:attribute>
											</gmd:MD_ScopeCode>
										</gmd:updateScope>
									</gmd:MD_MaintenanceInformation>
								</xsl:for-each>
							</gmd:resourceMaintenance>
							<xsl:for-each select="browse">
								<gmd:graphicOverview>
									<gmd:MD_BrowseGraphic>
										<gmd:fileName>
											<xsl:for-each-group select="." group-by="grp:key170c56f8(.)">
												<xsl:variable name="var444_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gco:CharacterString>
													<xsl:sequence select="$var444_cur_result_groupby"/>
												</gco:CharacterString>
											</xsl:for-each-group>
										</gmd:fileName>
										<gmd:fileDescription>
											<xsl:for-each select="browsed">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:fileDescription>
										<gmd:fileType>
											<xsl:for-each select="browset">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(xs:string(.))"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:fileType>
									</gmd:MD_BrowseGraphic>
								</gmd:graphicOverview>
							</xsl:for-each>
							<xsl:for-each-group select="keywords/theme" group-by="grp:key18fdb8d8(.)">
								<xsl:variable name="var453_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var454_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each-group select="$var453_cur_result_groupby" group-by="grp:key19fdc708(.)">
											<xsl:variable name="var464_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:sequence select="$var464_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each-group>
										<gmd:type>
											<gmd:MD_KeywordTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('theme'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('005'))"/>
												</xsl:attribute>
												<xsl:sequence select="'theme'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<gmd:thesaurusName>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space($var454_cur_result_groupby)"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string('Unknown'))"/>
													</xsl:attribute>
												</gmd:date>
											</gmd:CI_Citation>
										</gmd:thesaurusName>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each-group>
							<xsl:for-each-group select="keywords/place" group-by="grp:key18920260(.)">
								<xsl:variable name="var469_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var470_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each-group select="$var469_cur_result_groupby" group-by="grp:key19eccad8(.)">
											<xsl:variable name="var480_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:sequence select="$var480_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each-group>
										<gmd:type>
											<gmd:MD_KeywordTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('place'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
												</xsl:attribute>
												<xsl:sequence select="'place'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<gmd:thesaurusName>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space($var470_cur_result_groupby)"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string('Unknown'))"/>
													</xsl:attribute>
												</gmd:date>
											</gmd:CI_Citation>
										</gmd:thesaurusName>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each-group>
							<xsl:for-each-group select="keywords/stratum" group-by="grp:key156aa088(.)">
								<xsl:variable name="var485_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var486_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each-group select="$var485_cur_result_groupby" group-by="grp:key19fea208(.)">
											<xsl:variable name="var496_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:sequence select="$var496_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each-group>
										<gmd:type>
											<gmd:MD_KeywordTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('stratum'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('003'))"/>
												</xsl:attribute>
												<xsl:sequence select="'stratum'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<gmd:thesaurusName>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space($var486_cur_result_groupby)"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string('Unknown'))"/>
													</xsl:attribute>
												</gmd:date>
											</gmd:CI_Citation>
										</gmd:thesaurusName>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each-group>
							<xsl:for-each-group select="keywords/temporal" group-by="grp:key0d62a468(.)">
								<xsl:variable name="var501_cur_result_groupby" as="item()+" select="current-group()"/>
								<xsl:variable name="var502_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each-group select="$var501_cur_result_groupby" group-by="grp:key19b11470(.)">
											<xsl:variable name="var512_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:sequence select="$var512_cur_result_groupby"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each-group>
										<gmd:type>
											<gmd:MD_KeywordTypeCode>
												<xsl:attribute name="codeList">
													<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI('temporal'))"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:sequence select="xs:string(xs:anyURI('004'))"/>
												</xsl:attribute>
												<xsl:sequence select="'temporal'"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<gmd:thesaurusName>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:sequence select="fn:normalize-space($var502_cur_result_groupby)"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string('Unknown'))"/>
													</xsl:attribute>
												</gmd:date>
											</gmd:CI_Citation>
										</gmd:thesaurusName>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each-group>
							<gmd:resourceConstraints>
								<gmd:MD_LegalConstraints>
									<gmd:accessConstraints>
										<gmd:MD_RestrictionCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
											</xsl:attribute>
											<xsl:sequence select="'otherRestrictions'"/>
										</gmd:MD_RestrictionCode>
									</gmd:accessConstraints>
									<gmd:useConstraints>
										<gmd:MD_RestrictionCode>
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeListValue">
												<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
											</xsl:attribute>
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
											</xsl:attribute>
											<xsl:sequence select="'otherRestrictions'"/>
										</gmd:MD_RestrictionCode>
									</gmd:useConstraints>
									<gmd:otherConstraints>
										<xsl:for-each select="accconst">
											<xsl:variable name="var514_accconst" as="node()" select="."/>
											<xsl:for-each select="$var206_idinfo/useconst">
												<xsl:variable name="var516_useconst" as="node()" select="."/>
												<xsl:variable name="var518_cond_result_exists" as="xs:string?">
													<xsl:choose>
														<xsl:when test="fn:exists($var204_metadata/distinfo/distliab)">
															<xsl:variable name="var523_map_select_distinfo" as="xs:string*">
																<xsl:for-each select="$var204_metadata/distinfo/distliab">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:if test="fn:exists($var523_map_select_distinfo)">
																<xsl:sequence select="xs:string(fn:string-join($var523_map_select_distinfo, ' '))"/>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:sequence select="' '"/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var518_cond_result_exists">
													<gco:CharacterString>
														<xsl:variable name="var521_cond_result_exists" as="xs:string" select="(if (fn:exists($var204_metadata/distinfo/distliab)) then ' Distribution Liability: ' else ' ')"/>
														<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('Access Constraints: ', xs:string(xs:string($var514_accconst))), ' Use Constraints: '), xs:string(xs:string($var516_useconst))), $var521_cond_result_exists), .))"/>
													</gco:CharacterString>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
									</gmd:otherConstraints>
								</gmd:MD_LegalConstraints>
							</gmd:resourceConstraints>
							<xsl:for-each select="secinfo">
								<xsl:variable name="var526_secinfo" as="node()" select="."/>
								<gmd:resourceConstraints>
									<gmd:MD_SecurityConstraints>
										<gmd:classification>
											<xsl:variable name="var528_cond_result_exists" as="xs:string?">
												<xsl:choose>
													<xsl:when test="$var526_secinfo/secclass">
														<xsl:variable name="var541_map_select_secclass" as="xs:string*">
															<xsl:for-each select="secclass">
																<xsl:variable name="var544_result_vmf12_inputtoresult" as="xs:string?">
																	<xsl:call-template name="vmf:vmf12_inputtoresult">
																		<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:if test="fn:exists($var544_result_vmf12_inputtoresult)">
																	<xsl:sequence select="$var544_result_vmf12_inputtoresult"/>
																</xsl:if>
															</xsl:for-each>
														</xsl:variable>
														<xsl:if test="fn:exists($var541_map_select_secclass)">
															<xsl:sequence select="xs:string(fn:string-join($var541_map_select_secclass, ' '))"/>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="''"/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var528_cond_result_exists">
												<gmd:MD_ClassificationCode>
													<xsl:attribute name="codeList">
														<xsl:variable name="var531_cond_result_exists" as="xs:string" select="(if (fn:exists($var526_secinfo/secclass)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode' else '')"/>
														<xsl:sequence select="xs:string(xs:anyURI($var531_cond_result_exists))"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI(.))"/>
													</xsl:attribute>
													<xsl:variable name="var532_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="$var526_secinfo/secclass">
																<xsl:variable name="var536_map_select_secclass" as="xs:string*">
																	<xsl:for-each select="$var526_secinfo/secclass">
																		<xsl:variable name="var539_result_vmf13_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf13_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var539_result_vmf13_inputtoresult)">
																			<xsl:sequence select="$var539_result_vmf13_inputtoresult"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var536_map_select_secclass)">
																	<xsl:sequence select="xs:string(fn:string-join($var536_map_select_secclass, ' '))"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="''"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var532_cond_result_exists">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI(.))"/>
														</xsl:attribute>
													</xsl:for-each>
													<xsl:sequence select="."/>
												</gmd:MD_ClassificationCode>
											</xsl:for-each>
										</gmd:classification>
										<gmd:classificationSystem>
											<xsl:for-each select="secsys">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:classificationSystem>
										<gmd:handlingDescription>
											<xsl:for-each select="sechandl">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:handlingDescription>
									</gmd:MD_SecurityConstraints>
								</gmd:resourceConstraints>
							</xsl:for-each>
							<xsl:for-each select="citation/citeinfo/lworkcit">
								<xsl:variable name="var549_lworkcit" as="node()" select="."/>
								<gmd:aggregationInfo>
									<gmd:MD_AggregateInformation>
										<gmd:aggregateDataSetName>
											<xsl:for-each select="citeinfo">
												<xsl:variable name="var551_citeinfo" as="node()" select="."/>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="title">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:for-each select="pubdate">
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																		</xsl:attribute>
																	</xsl:if>
																</xsl:for-each>
																<xsl:for-each select="pubdate">
																	<xsl:variable name="var560_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var565_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var564_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var565_map_result_distinctvalues)">
																					<xsl:variable name="var570_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var570_cond_result_endswith)">
																						<xsl:sequence select="$var570_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var564_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var564_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var560_cond_result_logicalor">
																		<gco:Date>
																			<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																		</gco:Date>
																	</xsl:for-each>
																</xsl:for-each>
																<xsl:for-each select="pubdate">
																	<xsl:variable name="var580_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var613_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var612_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var613_map_result_distinctvalues)">
																					<xsl:variable name="var618_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var618_cond_result_endswith)">
																						<xsl:sequence select="$var618_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var612_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var612_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var580_cond_result_logicalor">
																		<xsl:variable name="var581_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var583_map_select_pubtime" as="xs:string*">
																			<xsl:for-each select="$var551_citeinfo/pubtime">
																				<xsl:variable name="var610_result_vmf5_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf5_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var609_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var610_result_vmf5_inputtoresult)) then (if (fn:contains($var610_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var609_cond_result_exists))">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var583_map_select_pubtime)">
																			<xsl:variable name="var588_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var588_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var588_cond_result_endswith)), 'Un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var588_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var588_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var588_cond_result_endswith))))) then 'T' else ()))">
																						<gco:DateTime>
																							<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var581_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var588_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var588_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var588_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var588_cond_result_endswith))))))"/>
																						</gco:DateTime>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</gmd:date>
															<gmd:dateType>
																<xsl:variable name="var625_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'publication' else ())"/>
																<xsl:if test="fn:exists($var625_cond_result_exists)">
																	<gmd:CI_DateTypeCode>
																		<xsl:variable name="var626_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																		<xsl:if test="fn:exists($var626_cond_result_exists)">
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI($var626_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI($var625_cond_result_exists))"/>
																		</xsl:attribute>
																		<xsl:variable name="var627_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then '002' else ())"/>
																		<xsl:if test="fn:exists($var627_cond_result_exists)">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI($var627_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var625_cond_result_exists"/>
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<gmd:edition>
														<xsl:for-each select="edition">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:edition>
													<xsl:for-each-group select="origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
														<xsl:variable name="var632_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:citedResponsibleParty>
															<gmd:CI_ResponsibleParty>
																<gmd:organisationName>
																	<gco:CharacterString>
																		<xsl:sequence select="$var632_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:organisationName>
															</gmd:CI_ResponsibleParty>
														</gmd:citedResponsibleParty>
													</xsl:for-each-group>
													<gmd:presentationForm>
														<xsl:variable name="var652_map_select_geoform" as="xs:string*">
															<xsl:for-each select="geoform">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var634_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($var652_map_select_geoform)">
																	<xsl:variable name="var654_map_select_geoform" as="xs:string*">
																		<xsl:for-each select="geoform">
																			<xsl:variable name="var657_result_vmf8_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf8_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var657_result_vmf8_inputtoresult)">
																				<xsl:sequence select="$var657_result_vmf8_inputtoresult"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var654_map_select_geoform)">
																		<xsl:sequence select="xs:string(fn:string-join($var654_map_select_geoform, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var634_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<xsl:attribute name="codeList">
																	<xsl:variable name="var638_map_select_geoform" as="xs:string*">
																		<xsl:for-each select="$var551_citeinfo/geoform">
																			<xsl:sequence select="xs:string(.)"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var637_cond_result_exists" as="xs:string" select="(if (fn:exists($var638_map_select_geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode' else '')"/>
																	<xsl:sequence select="xs:string(xs:anyURI($var637_cond_result_exists))"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																</xsl:attribute>
																<xsl:variable name="var644_map_select_geoform" as="xs:string*">
																	<xsl:for-each select="$var551_citeinfo/geoform">
																		<xsl:sequence select="xs:string(.)"/>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:variable name="var641_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists($var644_map_select_geoform)">
																			<xsl:variable name="var646_map_select_geoform" as="xs:string*">
																				<xsl:for-each select="$var551_citeinfo/geoform">
																					<xsl:variable name="var649_result_vmf9_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf9_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(.)))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var649_result_vmf9_inputtoresult)">
																						<xsl:sequence select="$var649_result_vmf9_inputtoresult"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var646_map_select_geoform)">
																				<xsl:sequence select="xs:string(fn:string-join($var646_map_select_geoform, ' '))"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="''"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var641_cond_result_exists">
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																	</xsl:attribute>
																</xsl:for-each>
																<xsl:sequence select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<xsl:for-each select="serinfo">
														<gmd:series>
															<gmd:CI_Series>
																<gmd:name>
																	<xsl:for-each select="sername">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:name>
																<gmd:issueIdentification>
																	<xsl:for-each select="issue">
																		<gco:CharacterString>
																			<xsl:sequence select="xs:string(.)"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</gmd:issueIdentification>
															</gmd:CI_Series>
														</gmd:series>
													</xsl:for-each>
													<gmd:otherCitationDetails>
														<xsl:for-each select="othercit">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</xsl:for-each>
										</gmd:aggregateDataSetName>
										<gmd:associationType>
											<xsl:variable name="var668_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'largerWorkCitation' else ())"/>
											<xsl:if test="fn:exists($var668_cond_result_exists)">
												<gmd:DS_AssociationTypeCode>
													<xsl:variable name="var669_cond_result_exists" as="xs:string?">
														<xsl:if test="fn:exists(citeinfo/origin)">
															<xsl:variable name="var671_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
															<xsl:if test="fn:exists($var671_cond_result_exists)">
																<xsl:sequence select="$var671_cond_result_exists"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var669_cond_result_exists)">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI($var669_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI($var668_cond_result_exists))"/>
													</xsl:attribute>
													<xsl:variable name="var672_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then '002' else ())"/>
													<xsl:if test="fn:exists($var672_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI($var672_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var668_cond_result_exists"/>
												</gmd:DS_AssociationTypeCode>
											</xsl:if>
										</gmd:associationType>
									</gmd:MD_AggregateInformation>
								</gmd:aggregationInfo>
							</xsl:for-each>
							<xsl:for-each select="crossref">
								<xsl:variable name="var673_crossref" as="node()" select="."/>
								<gmd:aggregationInfo>
									<gmd:MD_AggregateInformation>
										<gmd:aggregateDataSetName>
											<xsl:for-each select="citeinfo">
												<xsl:variable name="var675_citeinfo" as="node()" select="."/>
												<gmd:CI_Citation>
													<gmd:title>
														<xsl:for-each select="title">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:title>
													<gmd:date>
														<gmd:CI_Date>
															<gmd:date>
																<xsl:for-each select="pubdate">
																	<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																		</xsl:attribute>
																	</xsl:if>
																</xsl:for-each>
																<xsl:for-each select="pubdate">
																	<xsl:variable name="var684_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var689_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var688_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var689_map_result_distinctvalues)">
																					<xsl:variable name="var694_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var694_cond_result_endswith)">
																						<xsl:sequence select="$var694_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var688_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var688_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var684_cond_result_logicalor">
																		<gco:Date>
																			<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																		</gco:Date>
																	</xsl:for-each>
																</xsl:for-each>
																<xsl:variable name="var701_map_select_pubtime" as="xs:string*">
																	<xsl:for-each select="pubtime">
																		<xsl:variable name="var714_result_vmf5_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf5_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var713_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var714_result_vmf5_inputtoresult)) then (if (fn:contains($var714_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var713_cond_result_exists))">
																			<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var701_map_select_pubtime)">
																	<xsl:variable name="var706_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var706_cond_result_endswith)">
																		<gco:DateTime>
																			<xsl:sequence select="xs:string(xs:dateTime(fn:string($var706_cond_result_endswith)))"/>
																		</gco:DateTime>
																	</xsl:if>
																</xsl:for-each>
															</gmd:date>
															<gmd:dateType>
																<xsl:variable name="var715_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'publication' else ())"/>
																<xsl:if test="fn:exists($var715_cond_result_exists)">
																	<gmd:CI_DateTypeCode>
																		<xsl:variable name="var716_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																		<xsl:if test="fn:exists($var716_cond_result_exists)">
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI($var716_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI($var715_cond_result_exists))"/>
																		</xsl:attribute>
																		<xsl:variable name="var717_cond_result_exists" as="xs:string?" select="(if (fn:exists(pubdate)) then '002' else ())"/>
																		<xsl:if test="fn:exists($var717_cond_result_exists)">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI($var717_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:sequence select="$var715_cond_result_exists"/>
																	</gmd:CI_DateTypeCode>
																</xsl:if>
															</gmd:dateType>
														</gmd:CI_Date>
													</gmd:date>
													<gmd:edition>
														<xsl:for-each select="edition">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:edition>
													<xsl:for-each-group select="origin" group-by="fn:normalize-space(xs:string(xs:string(.)))">
														<xsl:variable name="var722_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:citedResponsibleParty>
															<gmd:CI_ResponsibleParty>
																<gmd:organisationName>
																	<gco:CharacterString>
																		<xsl:sequence select="$var722_cur_result_groupby"/>
																	</gco:CharacterString>
																</gmd:organisationName>
																<gmd:role>
																	<gmd:CI_RoleCode>
																		<xsl:attribute name="codeList">
																			<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI('originator'))"/>
																		</xsl:attribute>
																		<xsl:attribute name="codeSpace">
																			<xsl:sequence select="xs:string(xs:anyURI('006'))"/>
																		</xsl:attribute>
																		<xsl:sequence select="'originator'"/>
																	</gmd:CI_RoleCode>
																</gmd:role>
															</gmd:CI_ResponsibleParty>
														</gmd:citedResponsibleParty>
													</xsl:for-each-group>
													<gmd:presentationForm>
														<xsl:variable name="var724_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="$var675_citeinfo/geoform">
																	<xsl:variable name="var738_map_select_geoform" as="xs:string*">
																		<xsl:for-each select="geoform">
																			<xsl:variable name="var741_result_vmf6_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf6_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var741_result_vmf6_inputtoresult)">
																				<xsl:sequence select="$var741_result_vmf6_inputtoresult"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var738_map_select_geoform)">
																		<xsl:sequence select="xs:string(fn:string-join($var738_map_select_geoform, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:variable name="var742_map_select_geoform" as="xs:string*">
																		<xsl:for-each select="geoform">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var742_map_select_geoform)">
																		<xsl:sequence select="xs:string(fn:string-join($var742_map_select_geoform, ' '))"/>
																	</xsl:if>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var724_cond_result_exists">
															<gmd:CI_PresentationFormCode>
																<xsl:variable name="var727_cond_result_exists" as="xs:string?" select="(if (fn:exists($var675_citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
																<xsl:if test="fn:exists($var727_cond_result_exists)">
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI($var727_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																</xsl:attribute>
																<xsl:variable name="var728_cond_result_exists" as="xs:string?">
																	<xsl:if test="$var675_citeinfo/geoform">
																		<xsl:variable name="var732_map_select_geoform" as="xs:string*">
																			<xsl:for-each select="$var675_citeinfo/geoform">
																				<xsl:variable name="var735_result_vmf7_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf7_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var735_result_vmf7_inputtoresult)">
																					<xsl:sequence select="$var735_result_vmf7_inputtoresult"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var732_map_select_geoform)">
																			<xsl:sequence select="xs:string(fn:string-join($var732_map_select_geoform, ' '))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var728_cond_result_exists">
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																	</xsl:attribute>
																</xsl:for-each>
																<xsl:sequence select="."/>
															</gmd:CI_PresentationFormCode>
														</xsl:for-each>
													</gmd:presentationForm>
													<gmd:series>
														<gmd:CI_Series>
															<gmd:name>
																<xsl:for-each select="serinfo/sername">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:name>
															<gmd:issueIdentification>
																<xsl:for-each select="serinfo/issue">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:issueIdentification>
														</gmd:CI_Series>
													</gmd:series>
													<gmd:otherCitationDetails>
														<xsl:for-each select="othercit">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:otherCitationDetails>
												</gmd:CI_Citation>
											</xsl:for-each>
										</gmd:aggregateDataSetName>
										<gmd:associationType>
											<xsl:variable name="var751_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then 'crossReference' else ())"/>
											<xsl:if test="fn:exists($var751_cond_result_exists)">
												<gmd:DS_AssociationTypeCode>
													<xsl:variable name="var752_cond_result_exists" as="xs:string?">
														<xsl:if test="fn:exists(citeinfo/origin)">
															<xsl:variable name="var754_cond_result_exists" as="xs:string?" select="(if (fn:exists($var206_idinfo/citation/citeinfo/lworkcit/citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
															<xsl:if test="fn:exists($var754_cond_result_exists)">
																<xsl:sequence select="$var754_cond_result_exists"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var752_cond_result_exists)">
														<xsl:attribute name="codeList">
															<xsl:sequence select="xs:string(xs:anyURI($var752_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue">
														<xsl:sequence select="xs:string(xs:anyURI($var751_cond_result_exists))"/>
													</xsl:attribute>
													<xsl:variable name="var755_cond_result_exists" as="xs:string?" select="(if (fn:exists(citeinfo/origin)) then '001' else ())"/>
													<xsl:if test="fn:exists($var755_cond_result_exists)">
														<xsl:attribute name="codeSpace">
															<xsl:sequence select="xs:string(xs:anyURI($var755_cond_result_exists))"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:sequence select="$var751_cond_result_exists"/>
												</gmd:DS_AssociationTypeCode>
											</xsl:if>
										</gmd:associationType>
									</gmd:MD_AggregateInformation>
								</gmd:aggregationInfo>
							</xsl:for-each>
							<xsl:for-each select="$var204_metadata/spdoinfo">
								<gmd:spatialRepresentationType>
									<gmd:MD_SpatialRepresentationTypeCode>
										<xsl:variable name="var758_cond_result_exists" as="xs:string?" select="(if (fn:exists(direct)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode' else ())"/>
										<xsl:if test="fn:exists($var758_cond_result_exists)">
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI($var758_cond_result_exists))"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:for-each select="direct">
											<xsl:variable name="var761_result_vmf14_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf14_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var761_result_vmf14_inputtoresult)">
												<xsl:attribute name="codeListValue">
													<xsl:sequence select="xs:string(xs:anyURI($var761_result_vmf14_inputtoresult))"/>
												</xsl:attribute>
											</xsl:if>
										</xsl:for-each>
										<xsl:for-each select="direct">
											<xsl:variable name="var764_result_vmf14_inputtoresult" as="xs:string?">
												<xsl:call-template name="vmf:vmf14_inputtoresult">
													<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(fn:string(.)))"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:if test="fn:exists($var764_result_vmf14_inputtoresult)">
												<xsl:variable name="var765_result_vmf15_inputtoresult" as="xs:string?">
													<xsl:call-template name="vmf:vmf15_inputtoresult">
														<xsl:with-param name="input" select="$var764_result_vmf14_inputtoresult"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="fn:exists($var765_result_vmf15_inputtoresult)">
													<xsl:attribute name="codeSpace">
														<xsl:sequence select="xs:string(xs:anyURI($var765_result_vmf15_inputtoresult))"/>
													</xsl:attribute>
												</xsl:if>
											</xsl:if>
										</xsl:for-each>
									</gmd:MD_SpatialRepresentationTypeCode>
								</gmd:spatialRepresentationType>
							</xsl:for-each>
							<gmd:language>
								<gco:CharacterString>
									<xsl:sequence select="'eng; USA'"/>
								</gco:CharacterString>
							</gmd:language>
							<xsl:for-each select="keywords/theme">
								<xsl:variable name="var766_theme" as="node()" select="."/>
								<xsl:for-each select="themekey">
									<xsl:variable name="var768_themekey" as="node()" select="."/>
									<xsl:variable name="var776_map_select_themekt" as="xs:string*">
										<xsl:for-each select="$var766_theme/themekt">
											<xsl:if test="fn:contains(xs:string(xs:string(.)), 'ISO 19115')">
												<xsl:if test="((('0' != xs:string(.)) and ('false' != xs:string(.))) and fn:boolean(xs:string(.)))">
													<xsl:sequence select="xs:string($var768_themekey)"/>
												</xsl:if>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var770_map_result_distinctvalues" as="xs:boolean*">
										<xsl:for-each select="fn:distinct-values($var776_map_select_themekt)">
											<xsl:if test="((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))">
												<xsl:sequence select="fn:true()"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var770_map_result_distinctvalues)">
										<gmd:topicCategory>
											<xsl:variable name="var771_map_select_themekt" as="xs:string*">
												<xsl:for-each select="$var766_theme/themekt">
													<xsl:if test="fn:contains(xs:string(xs:string(.)), 'ISO 19115')">
														<xsl:if test="((('0' != xs:string(.)) and ('false' != xs:string(.))) and fn:boolean(xs:string(.)))">
															<xsl:sequence select="xs:string($var768_themekey)"/>
														</xsl:if>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:for-each select="fn:distinct-values($var771_map_select_themekt)">
												<gmd:MD_TopicCategoryCode>
													<xsl:sequence select="fn:normalize-space(.)"/>
												</gmd:MD_TopicCategoryCode>
											</xsl:for-each>
										</gmd:topicCategory>
									</xsl:if>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="native">
								<xsl:variable name="var781_native" as="node()" select="."/>
								<gmd:environmentDescription>
									<xsl:variable name="var783_cond_result_exists" as="xs:string?">
										<xsl:choose>
											<xsl:when test="fn:exists($var204_metadata/distinfo/techpreq)">
												<xsl:variable name="var788_map_select_distinfo" as="xs:string*">
													<xsl:for-each select="$var204_metadata/distinfo/techpreq">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:if test="fn:exists($var788_map_select_distinfo)">
													<xsl:sequence select="xs:string(fn:string-join($var788_map_select_distinfo, ' '))"/>
												</xsl:if>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="' '"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var783_cond_result_exists">
										<gco:CharacterString>
											<xsl:variable name="var786_cond_result_exists" as="xs:string" select="(if (fn:exists($var204_metadata/distinfo/techpreq)) then ' Technical Prerequisites: ' else ' ')"/>
											<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat('Native Dataset Environment: ', xs:string($var781_native)), $var786_cond_result_exists), .)))"/>
										</gco:CharacterString>
									</xsl:for-each>
								</gmd:environmentDescription>
							</xsl:for-each>
							<gmd:extent>
								<gmd:EX_Extent>
									<xsl:attribute name="id">
										<xsl:sequence select="xs:string(xs:ID('boundingExtent'))"/>
									</xsl:attribute>
									<gmd:geographicElement>
										<xsl:for-each select="spdom/dsgpoly/dsgpolyo">
											<xsl:variable name="var791_dsgpolyo" as="node()" select="."/>
											<gmd:EX_BoundingPolygon>
												<xsl:attribute name="id">
													<xsl:sequence select="xs:string(xs:ID('boundingPolygon'))"/>
												</xsl:attribute>
												<gmd:polygon>
													<gml:Polygon>
														<gml:interior>
															<gml:LinearRing>
																<gml:coordinates>
																	<xsl:variable name="var796_map_select_grngpoin" as="xs:string*">
																		<xsl:for-each select="grngpoin">
																			<xsl:variable name="var806_grngpoin" as="node()" select="."/>
																			<xsl:for-each select="gringlat">
																				<xsl:variable name="var808_gringlat" as="node()" select="."/>
																				<xsl:for-each select="$var806_grngpoin/gringlon">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double($var808_gringlat)), ', '), xs:string(xs:double(.))), '; ')"/>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var793_cond_result_exists" as="xs:string*">
																		<xsl:choose>
																			<xsl:when test="fn:exists($var796_map_select_grngpoin)">
																				<xsl:for-each select="grngpoin">
																					<xsl:variable name="var798_grngpoin" as="node()" select="."/>
																					<xsl:for-each select="gringlat">
																						<xsl:variable name="var800_gringlat" as="node()" select="."/>
																						<xsl:for-each select="$var798_grngpoin/gringlon">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(xs:string(xs:double($var800_gringlat)), ', '), xs:string(xs:double(.))), '; ')"/>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="gring">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var793_cond_result_exists">
																		<xsl:attribute name="decimal">
																			<xsl:sequence select="fn:normalize-space(.)"/>
																		</xsl:attribute>
																	</xsl:for-each>
																</gml:coordinates>
															</gml:LinearRing>
														</gml:interior>
													</gml:Polygon>
												</gmd:polygon>
											</gmd:EX_BoundingPolygon>
										</xsl:for-each>
										<xsl:for-each select="spdom/bounding">
											<gmd:EX_GeographicBoundingBox>
												<xsl:attribute name="id">
													<xsl:sequence select="xs:string(xs:ID('boundingGeographicBoundingBox'))"/>
												</xsl:attribute>
												<gmd:westBoundLongitude>
													<xsl:for-each select="westbc">
														<gco:Decimal>
															<xsl:sequence select="xs:string(xs:decimal(xs:double(.)))"/>
														</gco:Decimal>
													</xsl:for-each>
												</gmd:westBoundLongitude>
												<gmd:eastBoundLongitude>
													<xsl:for-each select="eastbc">
														<gco:Decimal>
															<xsl:sequence select="xs:string(xs:decimal(xs:double(.)))"/>
														</gco:Decimal>
													</xsl:for-each>
												</gmd:eastBoundLongitude>
												<gmd:southBoundLatitude>
													<xsl:for-each select="southbc">
														<gco:Decimal>
															<xsl:sequence select="xs:string(xs:decimal(xs:double(.)))"/>
														</gco:Decimal>
													</xsl:for-each>
												</gmd:southBoundLatitude>
												<gmd:northBoundLatitude>
													<xsl:for-each select="northbc">
														<gco:Decimal>
															<xsl:sequence select="xs:string(xs:decimal(xs:double(.)))"/>
														</gco:Decimal>
													</xsl:for-each>
												</gmd:northBoundLatitude>
											</gmd:EX_GeographicBoundingBox>
										</xsl:for-each>
									</gmd:geographicElement>
									<xsl:for-each select="timeperd">
										<xsl:variable name="var822_timeperd" as="node()" select="."/>
										<xsl:for-each select="timeinfo/sngdate">
											<xsl:variable name="var824_sngdate" as="node()" select="."/>
											<gmd:temporalElement>
												<gmd:EX_TemporalExtent>
													<gmd:extent>
														<xsl:for-each select="caldate">
															<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																<xsl:attribute name="gco:nilReason">
																	<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																</xsl:attribute>
															</xsl:if>
														</xsl:for-each>
														<gml:TimeInstant>
															<xsl:attribute name="gml:id">
																<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
															</xsl:attribute>
															<xsl:for-each select="$var822_timeperd/current">
																<gml:description>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:description>
															</xsl:for-each>
															<xsl:variable name="var956_map_select_caldate" as="xs:string*">
																<xsl:for-each select="caldate">
																	<xsl:variable name="var1029_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var1062_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1061_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1062_map_result_distinctvalues)">
																					<xsl:variable name="var1067_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1067_cond_result_endswith)">
																						<xsl:sequence select="$var1067_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1061_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var1061_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1029_cond_result_logicalor">
																		<xsl:variable name="var1030_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1032_map_select_time" as="xs:string*">
																			<xsl:for-each select="$var824_sngdate/time">
																				<xsl:variable name="var1059_result_vmf5_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf5_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1058_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1059_result_vmf5_inputtoresult)) then (if (fn:contains($var1059_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1058_cond_result_exists))">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1032_map_select_time)">
																			<xsl:variable name="var1037_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1037_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1037_cond_result_endswith)), 'Un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1037_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1037_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1037_cond_result_endswith))))) then 'T' else ()))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1030_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1037_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1037_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1037_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1037_cond_result_endswith))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var835_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var956_map_select_caldate)">
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var961_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var994_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var993_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var994_map_result_distinctvalues)">
																							<xsl:variable name="var999_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var999_cond_result_endswith)">
																								<xsl:sequence select="$var999_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var993_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var993_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var961_cond_result_logicalor">
																				<xsl:variable name="var962_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var964_map_select_time" as="xs:string*">
																					<xsl:for-each select="$var824_sngdate/time">
																						<xsl:variable name="var991_result_vmf5_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf5_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var990_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var991_result_vmf5_inputtoresult)) then (if (fn:contains($var991_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var990_cond_result_exists))">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var964_map_select_time)">
																					<xsl:variable name="var969_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var969_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var969_cond_result_endswith)), 'Un'))">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var969_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var969_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var969_cond_result_endswith))))) then 'T' else ()))">
																								<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var962_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var969_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var969_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var969_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var969_cond_result_endswith))))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1009_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1014_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1013_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1014_map_result_distinctvalues)">
																							<xsl:variable name="var1019_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1019_cond_result_endswith)">
																								<xsl:sequence select="$var1019_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1013_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1013_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1009_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:variable name="var830_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="$var835_cond_result_exists">
																		<xsl:variable name="var837_map_select_caldate" as="xs:string*">
																			<xsl:for-each select="caldate">
																				<xsl:variable name="var909_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																						<xsl:variable name="var942_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var941_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var942_map_result_distinctvalues)">
																								<xsl:variable name="var947_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var947_cond_result_endswith)">
																									<xsl:sequence select="$var947_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var941_map_result_distinctvalues)">
																							<xsl:sequence select="xs:string(fn:string-join($var941_map_result_distinctvalues, ' '))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var909_cond_result_logicalor">
																					<xsl:variable name="var910_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var912_map_select_time" as="xs:string*">
																						<xsl:for-each select="$var824_sngdate/time">
																							<xsl:variable name="var939_result_vmf5_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf5_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var938_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var939_result_vmf5_inputtoresult)) then (if (fn:contains($var939_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var938_cond_result_exists))">
																								<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var912_map_select_time)">
																						<xsl:variable name="var917_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var917_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var917_cond_result_endswith)), 'Un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var917_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var917_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var917_cond_result_endswith))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var910_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var917_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var917_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var917_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var917_cond_result_endswith))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:exists($var837_map_select_caldate)">
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var841_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var874_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var873_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var874_map_result_distinctvalues)">
																									<xsl:variable name="var879_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var879_cond_result_endswith)">
																										<xsl:sequence select="$var879_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var873_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var873_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var841_cond_result_logicalor">
																						<xsl:variable name="var842_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var844_map_select_time" as="xs:string*">
																							<xsl:for-each select="$var824_sngdate/time">
																								<xsl:variable name="var871_result_vmf5_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf5_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var870_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var871_result_vmf5_inputtoresult)) then (if (fn:contains($var871_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var870_cond_result_exists))">
																									<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var844_map_select_time)">
																							<xsl:variable name="var849_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var849_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var849_cond_result_endswith)), 'Un'))">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var849_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var849_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var849_cond_result_endswith))))) then 'T' else ()))">
																										<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var842_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var849_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var849_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var849_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var849_cond_result_endswith))))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var889_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var894_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var893_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var894_map_result_distinctvalues)">
																									<xsl:variable name="var899_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var899_cond_result_endswith)">
																										<xsl:sequence select="$var899_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var893_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var893_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var889_cond_result_logicalor">
																						<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:choose>
																				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																					<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="''"/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var830_cond_result_exists">
																<gml:timePosition>
																	<xsl:for-each select="$var824_sngdate/caldate">
																		<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																			<xsl:attribute name="indeterminatePosition">
																				<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																			</xsl:attribute>
																		</xsl:if>
																	</xsl:for-each>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:timePosition>
															</xsl:for-each>
														</gml:TimeInstant>
													</gmd:extent>
												</gmd:EX_TemporalExtent>
											</gmd:temporalElement>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="timeperd">
										<xsl:variable name="var1074_timeperd" as="node()" select="."/>
										<xsl:for-each select="timeinfo/mdattim/sngdate">
											<xsl:variable name="var1076_sngdate" as="node()" select="."/>
											<gmd:temporalElement>
												<gmd:EX_TemporalExtent>
													<gmd:extent>
														<xsl:for-each select="caldate">
															<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																<xsl:attribute name="gco:nilReason">
																	<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																</xsl:attribute>
															</xsl:if>
														</xsl:for-each>
														<gml:TimeInstant>
															<xsl:attribute name="gml:id">
																<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
															</xsl:attribute>
															<xsl:for-each select="$var1074_timeperd/current">
																<gml:description>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:description>
															</xsl:for-each>
															<xsl:variable name="var1212_map_select_caldate" as="xs:string*">
																<xsl:for-each select="caldate">
																	<xsl:variable name="var1285_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var1318_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1317_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1318_map_result_distinctvalues)">
																					<xsl:variable name="var1323_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1323_cond_result_endswith)">
																						<xsl:sequence select="$var1323_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1317_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var1317_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1285_cond_result_logicalor">
																		<xsl:variable name="var1286_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1288_map_select_time" as="xs:string*">
																			<xsl:for-each select="$var1076_sngdate/time">
																				<xsl:variable name="var1315_result_vmf5_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf5_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1314_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1315_result_vmf5_inputtoresult)) then (if (fn:contains($var1315_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1314_cond_result_exists))">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1288_map_select_time)">
																			<xsl:variable name="var1293_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1293_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1293_cond_result_endswith)), 'Un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1293_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1293_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1293_cond_result_endswith))))) then 'T' else ()))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1286_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1293_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1293_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1293_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1293_cond_result_endswith))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1091_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var1212_map_select_caldate)">
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1217_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1250_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1249_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1250_map_result_distinctvalues)">
																							<xsl:variable name="var1255_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1255_cond_result_endswith)">
																								<xsl:sequence select="$var1255_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1249_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1249_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1217_cond_result_logicalor">
																				<xsl:variable name="var1218_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1220_map_select_time" as="xs:string*">
																					<xsl:for-each select="$var1076_sngdate/time">
																						<xsl:variable name="var1247_result_vmf5_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf5_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1246_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1247_result_vmf5_inputtoresult)) then (if (fn:contains($var1247_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1246_cond_result_exists))">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1220_map_select_time)">
																					<xsl:variable name="var1225_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1225_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1225_cond_result_endswith)), 'Un'))">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1225_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1225_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1225_cond_result_endswith))))) then 'T' else ()))">
																								<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1218_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1225_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1225_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1225_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1225_cond_result_endswith))))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:variable name="var1265_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1270_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1269_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1270_map_result_distinctvalues)">
																							<xsl:variable name="var1275_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1275_cond_result_endswith)">
																								<xsl:sequence select="$var1275_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1269_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1269_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1265_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:variable name="var1082_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="$var1091_cond_result_exists">
																		<xsl:variable name="var1093_map_select_caldate" as="xs:string*">
																			<xsl:for-each select="caldate">
																				<xsl:variable name="var1165_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																						<xsl:variable name="var1198_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1197_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1198_map_result_distinctvalues)">
																								<xsl:variable name="var1203_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1203_cond_result_endswith)">
																									<xsl:sequence select="$var1203_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1197_map_result_distinctvalues)">
																							<xsl:sequence select="xs:string(fn:string-join($var1197_map_result_distinctvalues, ' '))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var1165_cond_result_logicalor">
																					<xsl:variable name="var1166_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1168_map_select_time" as="xs:string*">
																						<xsl:for-each select="$var1076_sngdate/time">
																							<xsl:variable name="var1195_result_vmf5_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf5_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1194_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1195_result_vmf5_inputtoresult)) then (if (fn:contains($var1195_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1194_cond_result_exists))">
																								<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var1168_map_select_time)">
																						<xsl:variable name="var1173_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1173_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1173_cond_result_endswith)), 'Un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1173_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1173_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1173_cond_result_endswith))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1166_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1173_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1173_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1173_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1173_cond_result_endswith))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1093_map_select_caldate)">
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var1097_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1130_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1129_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1130_map_result_distinctvalues)">
																									<xsl:variable name="var1135_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1135_cond_result_endswith)">
																										<xsl:sequence select="$var1135_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1129_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1129_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1097_cond_result_logicalor">
																						<xsl:variable name="var1098_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var1100_map_select_time" as="xs:string*">
																							<xsl:for-each select="$var1076_sngdate/time">
																								<xsl:variable name="var1127_result_vmf5_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf5_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1126_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1127_result_vmf5_inputtoresult)) then (if (fn:contains($var1127_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var1126_cond_result_exists))">
																									<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var1100_map_select_time)">
																							<xsl:variable name="var1105_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1105_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1105_cond_result_endswith)), 'Un'))">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1105_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1105_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1105_cond_result_endswith))))) then 'T' else ()))">
																										<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1098_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1105_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1105_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1105_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1105_cond_result_endswith))))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="caldate">
																					<xsl:variable name="var1145_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1150_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1149_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1150_map_result_distinctvalues)">
																									<xsl:variable name="var1155_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1155_cond_result_endswith)">
																										<xsl:sequence select="$var1155_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1149_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1149_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1145_cond_result_logicalor">
																						<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="caldate">
																			<xsl:choose>
																				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																					<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="''"/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var1082_cond_result_exists">
																<gml:timePosition>
																	<xsl:variable name="var1088_map_select_caldate" as="xs:string*">
																		<xsl:for-each select="$var1076_sngdate/caldate">
																			<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																				<xsl:sequence select="'now'"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var1085_cond_result_exists" as="xs:string*" select="(if (fn:exists($var1088_map_select_caldate)) then $var1088_map_select_caldate else 'unknown')"/>
																	<xsl:for-each select="$var1085_cond_result_exists">
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:sequence select="."/>
																		</xsl:attribute>
																	</xsl:for-each>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:timePosition>
															</xsl:for-each>
														</gml:TimeInstant>
													</gmd:extent>
												</gmd:EX_TemporalExtent>
											</gmd:temporalElement>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="timeperd">
										<xsl:variable name="var1330_timeperd" as="node()" select="."/>
										<xsl:for-each select="timeinfo/rngdates">
											<xsl:variable name="var1332_rngdates" as="node()" select="."/>
											<gmd:temporalElement>
												<xsl:for-each select="begdate">
													<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
														</xsl:attribute>
													</xsl:if>
												</xsl:for-each>
												<gmd:EX_TemporalExtent>
													<gmd:extent>
														<gml:TimePeriod>
															<xsl:attribute name="gml:id">
																<xsl:sequence select="xs:string(xs:ID('boundingTemporalExtent'))"/>
															</xsl:attribute>
															<xsl:for-each select="$var1330_timeperd/current">
																<gml:description>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:description>
															</xsl:for-each>
															<xsl:variable name="var1464_map_select_begdate" as="xs:string*">
																<xsl:for-each select="begdate">
																	<xsl:variable name="var1537_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var1570_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1569_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1570_map_result_distinctvalues)">
																					<xsl:variable name="var1575_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1575_cond_result_endswith)">
																						<xsl:sequence select="$var1575_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1569_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var1569_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1537_cond_result_logicalor">
																		<xsl:variable name="var1538_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1540_map_select_begtime" as="xs:string*">
																			<xsl:for-each select="$var1332_rngdates/begtime">
																				<xsl:variable name="var1567_result_vmf5_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf5_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1566_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1567_result_vmf5_inputtoresult)) then (if (fn:contains($var1567_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1566_cond_result_exists))">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1540_map_select_begtime)">
																			<xsl:variable name="var1545_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1545_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1545_cond_result_endswith)), 'Un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1545_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1545_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1545_cond_result_endswith))))) then 'T' else ()))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1538_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1545_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1545_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1545_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1545_cond_result_endswith))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1343_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var1464_map_select_begdate)">
																		<xsl:for-each select="begdate">
																			<xsl:variable name="var1469_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1502_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1501_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1502_map_result_distinctvalues)">
																							<xsl:variable name="var1507_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1507_cond_result_endswith)">
																								<xsl:sequence select="$var1507_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1501_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1501_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1469_cond_result_logicalor">
																				<xsl:variable name="var1470_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1472_map_select_begtime" as="xs:string*">
																					<xsl:for-each select="$var1332_rngdates/begtime">
																						<xsl:variable name="var1499_result_vmf5_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf5_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1498_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1499_result_vmf5_inputtoresult)) then (if (fn:contains($var1499_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1498_cond_result_exists))">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1472_map_select_begtime)">
																					<xsl:variable name="var1477_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1477_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1477_cond_result_endswith)), 'Un'))">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1477_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1477_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1477_cond_result_endswith))))) then 'T' else ()))">
																								<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1470_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1477_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1477_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1477_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1477_cond_result_endswith))))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="begdate">
																			<xsl:variable name="var1517_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1522_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1521_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1522_map_result_distinctvalues)">
																							<xsl:variable name="var1527_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1527_cond_result_endswith)">
																								<xsl:sequence select="$var1527_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1521_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1521_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1517_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:variable name="var1338_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="$var1343_cond_result_exists">
																		<xsl:variable name="var1345_map_select_begdate" as="xs:string*">
																			<xsl:for-each select="begdate">
																				<xsl:variable name="var1417_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																						<xsl:variable name="var1450_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1449_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1450_map_result_distinctvalues)">
																								<xsl:variable name="var1455_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1455_cond_result_endswith)">
																									<xsl:sequence select="$var1455_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1449_map_result_distinctvalues)">
																							<xsl:sequence select="xs:string(fn:string-join($var1449_map_result_distinctvalues, ' '))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var1417_cond_result_logicalor">
																					<xsl:variable name="var1418_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1420_map_select_begtime" as="xs:string*">
																						<xsl:for-each select="$var1332_rngdates/begtime">
																							<xsl:variable name="var1447_result_vmf5_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf5_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1446_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1447_result_vmf5_inputtoresult)) then (if (fn:contains($var1447_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1446_cond_result_exists))">
																								<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var1420_map_select_begtime)">
																						<xsl:variable name="var1425_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1425_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1425_cond_result_endswith)), 'Un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1425_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1425_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1425_cond_result_endswith))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1418_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1425_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1425_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1425_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1425_cond_result_endswith))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1345_map_select_begdate)">
																				<xsl:for-each select="begdate">
																					<xsl:variable name="var1349_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1382_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1381_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1382_map_result_distinctvalues)">
																									<xsl:variable name="var1387_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1387_cond_result_endswith)">
																										<xsl:sequence select="$var1387_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1381_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1381_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1349_cond_result_logicalor">
																						<xsl:variable name="var1350_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var1352_map_select_begtime" as="xs:string*">
																							<xsl:for-each select="$var1332_rngdates/begtime">
																								<xsl:variable name="var1379_result_vmf5_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf5_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1378_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1379_result_vmf5_inputtoresult)) then (if (fn:contains($var1379_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var1378_cond_result_exists))">
																									<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var1352_map_select_begtime)">
																							<xsl:variable name="var1357_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1357_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1357_cond_result_endswith)), 'Un'))">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1357_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1357_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1357_cond_result_endswith))))) then 'T' else ()))">
																										<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1350_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1357_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1357_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1357_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1357_cond_result_endswith))))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="begdate">
																					<xsl:variable name="var1397_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1402_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1401_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1402_map_result_distinctvalues)">
																									<xsl:variable name="var1407_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1407_cond_result_endswith)">
																										<xsl:sequence select="$var1407_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1401_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1401_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1397_cond_result_logicalor">
																						<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="begdate">
																			<xsl:choose>
																				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																					<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="''"/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var1338_cond_result_exists">
																<gml:beginPosition>
																	<xsl:for-each select="$var1332_rngdates/begdate">
																		<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																			<xsl:attribute name="indeterminatePosition">
																				<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																			</xsl:attribute>
																		</xsl:if>
																	</xsl:for-each>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:beginPosition>
															</xsl:for-each>
															<xsl:variable name="var1708_map_select_enddate" as="xs:string*">
																<xsl:for-each select="enddate">
																	<xsl:variable name="var1781_cond_result_logicalor" as="xs:string?">
																		<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																			<xsl:variable name="var1814_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(., '-')">
																							<xsl:if test="fn:ends-with(., '-')">
																								<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																									<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:variable name="var1813_map_result_distinctvalues" as="xs:string*">
																				<xsl:for-each select="fn:distinct-values($var1814_map_result_distinctvalues)">
																					<xsl:variable name="var1819_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																										<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1819_cond_result_endswith)">
																						<xsl:sequence select="$var1819_cond_result_endswith"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1813_map_result_distinctvalues)">
																				<xsl:sequence select="xs:string(fn:string-join($var1813_map_result_distinctvalues, ' '))"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:variable>
																	<xsl:for-each select="$var1781_cond_result_logicalor">
																		<xsl:variable name="var1782_cur_cond_result_logicalor" as="xs:string" select="."/>
																		<xsl:variable name="var1784_map_select_endtime" as="xs:string*">
																			<xsl:for-each select="$var1332_rngdates/endtime">
																				<xsl:variable name="var1811_result_vmf5_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf5_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:variable name="var1810_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1811_result_vmf5_inputtoresult)) then (if (fn:contains($var1811_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																				<xsl:if test="not(fn:exists($var1810_cond_result_exists))">
																					<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:for-each select="fn:distinct-values($var1784_map_select_endtime)">
																			<xsl:variable name="var1789_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., ':')">
																						<xsl:if test="fn:ends-with(., ':')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var1789_cond_result_endswith)">
																				<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1789_cond_result_endswith)), 'Un'))">
																					<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1789_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1789_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1789_cond_result_endswith))))) then 'T' else ()))">
																						<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1782_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1789_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1789_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1789_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1789_cond_result_endswith))))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1587_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="fn:exists($var1708_map_select_enddate)">
																		<xsl:for-each select="enddate">
																			<xsl:variable name="var1713_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1746_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1745_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1746_map_result_distinctvalues)">
																							<xsl:variable name="var1751_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1751_cond_result_endswith)">
																								<xsl:sequence select="$var1751_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1745_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1745_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1713_cond_result_logicalor">
																				<xsl:variable name="var1714_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var1716_map_select_endtime" as="xs:string*">
																					<xsl:for-each select="$var1332_rngdates/endtime">
																						<xsl:variable name="var1743_result_vmf5_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf5_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var1742_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1743_result_vmf5_inputtoresult)) then (if (fn:contains($var1743_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var1742_cond_result_exists))">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var1716_map_select_endtime)">
																					<xsl:variable name="var1721_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1721_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1721_cond_result_endswith)), 'Un'))">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1721_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1721_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1721_cond_result_endswith))))) then 'T' else ()))">
																								<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1714_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1721_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1721_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1721_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1721_cond_result_endswith))))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="enddate">
																			<xsl:variable name="var1761_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var1766_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var1765_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var1766_map_result_distinctvalues)">
																							<xsl:variable name="var1771_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1771_cond_result_endswith)">
																								<xsl:sequence select="$var1771_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var1765_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var1765_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var1761_cond_result_logicalor">
																				<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																			</xsl:for-each>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:variable name="var1582_cond_result_exists" as="xs:string*">
																<xsl:choose>
																	<xsl:when test="$var1587_cond_result_exists">
																		<xsl:variable name="var1589_map_select_enddate" as="xs:string*">
																			<xsl:for-each select="enddate">
																				<xsl:variable name="var1661_cond_result_logicalor" as="xs:string?">
																					<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																						<xsl:variable name="var1694_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., '-')">
																										<xsl:if test="fn:ends-with(., '-')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var1693_map_result_distinctvalues" as="xs:string*">
																							<xsl:for-each select="fn:distinct-values($var1694_map_result_distinctvalues)">
																								<xsl:variable name="var1699_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																													<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var1699_cond_result_endswith)">
																									<xsl:sequence select="$var1699_cond_result_endswith"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1693_map_result_distinctvalues)">
																							<xsl:sequence select="xs:string(fn:string-join($var1693_map_result_distinctvalues, ' '))"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:variable>
																				<xsl:for-each select="$var1661_cond_result_logicalor">
																					<xsl:variable name="var1662_cur_cond_result_logicalor" as="xs:string" select="."/>
																					<xsl:variable name="var1664_map_select_endtime" as="xs:string*">
																						<xsl:for-each select="$var1332_rngdates/endtime">
																							<xsl:variable name="var1691_result_vmf5_inputtoresult" as="xs:string?">
																								<xsl:call-template name="vmf:vmf5_inputtoresult">
																									<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																								</xsl:call-template>
																							</xsl:variable>
																							<xsl:variable name="var1690_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1691_result_vmf5_inputtoresult)) then (if (fn:contains($var1691_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																							<xsl:if test="not(fn:exists($var1690_cond_result_exists))">
																								<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:for-each select="fn:distinct-values($var1664_map_select_endtime)">
																						<xsl:variable name="var1669_cond_result_endswith" as="xs:string?">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., ':')">
																									<xsl:if test="fn:ends-with(., ':')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var1669_cond_result_endswith)">
																							<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1669_cond_result_endswith)), 'Un'))">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1669_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1669_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1669_cond_result_endswith))))) then 'T' else ()))">
																									<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1662_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1669_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1669_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1669_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1669_cond_result_endswith))))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:choose>
																			<xsl:when test="fn:exists($var1589_map_select_enddate)">
																				<xsl:for-each select="enddate">
																					<xsl:variable name="var1593_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1626_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1625_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1626_map_result_distinctvalues)">
																									<xsl:variable name="var1631_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1631_cond_result_endswith)">
																										<xsl:sequence select="$var1631_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1625_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1625_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1593_cond_result_logicalor">
																						<xsl:variable name="var1594_cur_cond_result_logicalor" as="xs:string" select="."/>
																						<xsl:variable name="var1596_map_select_endtime" as="xs:string*">
																							<xsl:for-each select="$var1332_rngdates/endtime">
																								<xsl:variable name="var1623_result_vmf5_inputtoresult" as="xs:string?">
																									<xsl:call-template name="vmf:vmf5_inputtoresult">
																										<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:variable name="var1622_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1623_result_vmf5_inputtoresult)) then (if (fn:contains($var1623_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																								<xsl:if test="not(fn:exists($var1622_cond_result_exists))">
																									<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:for-each select="fn:distinct-values($var1596_map_select_endtime)">
																							<xsl:variable name="var1601_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(., ':')">
																										<xsl:if test="fn:ends-with(., ':')">
																											<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																												<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1601_cond_result_endswith)">
																								<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1601_cond_result_endswith)), 'Un'))">
																									<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1601_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1601_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1601_cond_result_endswith))))) then 'T' else ()))">
																										<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1594_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1601_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1601_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1601_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1601_cond_result_endswith))))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="enddate">
																					<xsl:variable name="var1641_cond_result_logicalor" as="xs:string?">
																						<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																							<xsl:variable name="var1646_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., '-')">
																											<xsl:if test="fn:ends-with(., '-')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:variable name="var1645_map_result_distinctvalues" as="xs:string*">
																								<xsl:for-each select="fn:distinct-values($var1646_map_result_distinctvalues)">
																									<xsl:variable name="var1651_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																												<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																														<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var1651_cond_result_endswith)">
																										<xsl:sequence select="$var1651_cond_result_endswith"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var1645_map_result_distinctvalues)">
																								<xsl:sequence select="xs:string(fn:string-join($var1645_map_result_distinctvalues, ' '))"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:variable>
																					<xsl:for-each select="$var1641_cond_result_logicalor">
																						<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																					</xsl:for-each>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:for-each select="enddate">
																			<xsl:choose>
																				<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																					<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="''"/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var1582_cond_result_exists">
																<gml:endPosition>
																	<xsl:for-each select="$var1332_rngdates/enddate">
																		<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																			<xsl:attribute name="indeterminatePosition">
																				<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																			</xsl:attribute>
																		</xsl:if>
																	</xsl:for-each>
																	<xsl:sequence select="xs:string(xs:string(.))"/>
																</gml:endPosition>
															</xsl:for-each>
														</gml:TimePeriod>
													</gmd:extent>
												</gmd:EX_TemporalExtent>
											</gmd:temporalElement>
										</xsl:for-each>
									</xsl:for-each>
								</gmd:EX_Extent>
							</gmd:extent>
							<xsl:for-each select="descript/supplinf">
								<gmd:supplementalInformation>
									<gco:CharacterString>
										<xsl:sequence select="xs:string(.)"/>
									</gco:CharacterString>
								</gmd:supplementalInformation>
							</xsl:for-each>
						</gmd:MD_DataIdentification>
					</gmd:identificationInfo>
				</xsl:for-each>
			</xsl:for-each>
			<gmd:contentInfo>
				<gmd:MD_FeatureCatalogueDescription>
					<gmd:includedWithDataset>
						<gco:Boolean>
							<xsl:variable name="var1828_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
							<xsl:sequence select="xs:string(fn:boolean($var1828_cond_result_exists))"/>
						</gco:Boolean>
					</gmd:includedWithDataset>
					<xsl:for-each select="$var1_instance/metadata/eainfo/detailed/enttyp/enttypl">
						<gmd:featureTypes>
							<gco:LocalName>
								<xsl:attribute name="codeSpace">
									<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(xs:string(.))))"/>
								</xsl:attribute>
							</gco:LocalName>
						</gmd:featureTypes>
					</xsl:for-each>
					<gmd:featureCatalogueCitation>
						<xsl:variable name="var1831_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var1_instance/metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
						<xsl:if test="fn:exists((if ((xs:string($var1831_cond_result_exists) = 'false')) then () else 'unknown'))">
							<xsl:attribute name="gco:nilReason">
								<xsl:sequence select="xs:string(xs:string((if ((xs:string($var1831_cond_result_exists) = 'false')) then () else 'unknown')))"/>
							</xsl:attribute>
						</xsl:if>
						<xsl:variable name="var1832_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eaover)) then 'Entity and Attribute Overview: ' else ())"/>
						<xsl:if test="fn:exists($var1832_cond_result_exists)">
							<xsl:variable name="var1833_cond_result_exists" as="xs:string?">
								<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eaover)">
									<xsl:variable name="var1845_map_select_metadata" as="xs:string*">
										<xsl:for-each select="$var1_instance/metadata/eainfo/overview/eaover">
											<xsl:sequence select="xs:string(.)"/>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var1845_map_select_metadata)">
										<xsl:sequence select="xs:string(fn:string-join($var1845_map_select_metadata, ' '))"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var1833_cond_result_exists">
								<xsl:variable name="var1834_cur_cond_result_exists" as="xs:string" select="."/>
								<xsl:variable name="var1836_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)) then '   Entity and Attribute Detail Citation: ' else ())"/>
								<xsl:if test="fn:exists($var1836_cond_result_exists)">
									<xsl:variable name="var1837_cond_result_exists" as="xs:string?">
										<xsl:if test="fn:exists($var1_instance/metadata/eainfo/overview/eadetcit)">
											<xsl:variable name="var1841_map_select_metadata" as="xs:string*">
												<xsl:for-each select="$var1_instance/metadata/eainfo/overview/eadetcit">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var1841_map_select_metadata)">
												<xsl:sequence select="xs:string(fn:string-join($var1841_map_select_metadata, ' '))"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var1837_cond_result_exists">
										<gmd:CI_Citation>
											<gmd:otherCitationDetails>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat($var1832_cond_result_exists, $var1834_cur_cond_result_exists), $var1836_cond_result_exists), .))"/>
												</gco:CharacterString>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</xsl:for-each>
								</xsl:if>
							</xsl:for-each>
						</xsl:if>
					</gmd:featureCatalogueCitation>
				</gmd:MD_FeatureCatalogueDescription>
				<xsl:for-each select="$var1_instance/metadata/dataqual/cloud">
					<gmd:MD_ImageDescription>
						<gmd:cloudCoverPercentage>
							<xsl:if test="fn:contains(xs:string(xs:string(.)), 'Unknown')">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(xs:string(xs:string(.))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:if test="not(fn:contains(xs:string(xs:string(.)), 'Unknown'))">
								<gco:Real>
									<xsl:sequence select="xs:string(xs:double(xs:string(.)))"/>
								</gco:Real>
							</xsl:if>
						</gmd:cloudCoverPercentage>
					</gmd:MD_ImageDescription>
				</xsl:for-each>
			</gmd:contentInfo>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var1850_metadata" as="node()" select="."/>
				<xsl:for-each select="distinfo">
					<xsl:variable name="var1852_distinfo" as="node()" select="."/>
					<gmd:distributionInfo>
						<gmd:MD_Distribution>
							<xsl:for-each select="stdorder/digform">
								<xsl:variable name="var1854_digform" as="node()" select="."/>
								<gmd:distributionFormat>
									<gmd:MD_Format>
										<xsl:for-each select="digtinfo/formname">
											<gmd:name>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
												</gco:CharacterString>
											</gmd:name>
										</xsl:for-each>
										<gmd:version>
											<xsl:variable name="var1858_cond_result_exists" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:exists(digtinfo/formvern)">
														<xsl:variable name="var1862_map_select_digtinfo" as="xs:string*">
															<xsl:for-each select="digtinfo/formvern">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:if test="fn:exists($var1862_map_select_digtinfo)">
															<xsl:sequence select="xs:string(fn:string-join($var1862_map_select_digtinfo, ' '))"/>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="'unknown'"/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:for-each select="$var1858_cond_result_exists">
												<xsl:if test="(. = 'unknown')">
													<xsl:attribute name="gco:nilReason">
														<xsl:sequence select="xs:string(xs:string(.))"/>
													</xsl:attribute>
												</xsl:if>
											</xsl:for-each>
											<xsl:for-each select="digtinfo">
												<xsl:variable name="var1865_digtinfo" as="node()" select="."/>
												<xsl:for-each select="formvern">
													<xsl:variable name="var1867_formvern" as="node()" select="."/>
													<xsl:variable name="var1870_cond_result_equal" as="xs:string?">
														<xsl:if test="not((fn:lower-case(xs:string(.)) = 'unknown'))">
															<xsl:variable name="var1876_map_select_formverd" as="xs:string*">
																<xsl:for-each select="$var1865_digtinfo/formverd">
																	<xsl:sequence select="fn:string(.)"/>
																</xsl:for-each>
															</xsl:variable>
															<xsl:variable name="var1873_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var1876_map_select_formverd)">
																		<xsl:variable name="var1878_map_select_formverd" as="xs:string*">
																			<xsl:for-each select="$var1865_digtinfo/formverd">
																				<xsl:sequence select="fn:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var1878_map_select_formverd)">
																			<xsl:sequence select="xs:string(fn:string-join($var1878_map_select_formverd, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var1873_cond_result_exists">
																<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(xs:string($var1867_formvern), .)))"/>
															</xsl:for-each>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="fn:exists($var1870_cond_result_equal)">
														<gco:CharacterString>
															<xsl:sequence select="$var1870_cond_result_equal"/>
														</gco:CharacterString>
													</xsl:if>
												</xsl:for-each>
											</xsl:for-each>
										</gmd:version>
										<xsl:for-each select="digtinfo/formspec">
											<gmd:specification>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
												</gco:CharacterString>
											</gmd:specification>
										</xsl:for-each>
										<xsl:for-each select="digtinfo/filedec">
											<gmd:fileDecompressionTechnique>
												<gco:CharacterString>
													<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
												</gco:CharacterString>
											</gmd:fileDecompressionTechnique>
										</xsl:for-each>
									</gmd:MD_Format>
								</gmd:distributionFormat>
							</xsl:for-each>
							<xsl:for-each select="distrib">
								<gmd:distributor>
									<gmd:MD_Distributor>
										<xsl:for-each select="cntinfo">
											<xsl:variable name="var1889_cntinfo" as="node()" select="."/>
											<gmd:distributorContact>
												<gmd:CI_ResponsibleParty>
													<xsl:variable name="var1894_map_select_cntperp" as="xs:string*">
														<xsl:for-each select="cntperp/cntper">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1891_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1894_map_select_cntperp)">
																<xsl:for-each select="cntperp/cntper">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="cntorgp/cntper">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1891_cond_result_exists">
														<gmd:individualName>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(.)"/>
															</gco:CharacterString>
														</gmd:individualName>
													</xsl:for-each>
													<xsl:variable name="var1905_map_select_cntperp" as="xs:string*">
														<xsl:for-each select="cntperp/cntorg">
															<xsl:sequence select="xs:string(.)"/>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var1902_cond_result_exists" as="xs:string*">
														<xsl:choose>
															<xsl:when test="fn:exists($var1905_map_select_cntperp)">
																<xsl:for-each select="cntperp/cntorg">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:when>
															<xsl:otherwise>
																<xsl:for-each select="cntorgp/cntorg">
																	<xsl:sequence select="xs:string(.)"/>
																</xsl:for-each>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var1902_cond_result_exists">
														<gmd:organisationName>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(.)"/>
															</gco:CharacterString>
														</gmd:organisationName>
													</xsl:for-each>
													<xsl:for-each select="cntpos">
														<gmd:positionName>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:positionName>
													</xsl:for-each>
													<gmd:contactInfo>
														<gmd:CI_Contact>
															<gmd:phone>
																<gmd:CI_Telephone>
																	<xsl:for-each-group select="cntvoice" group-by="fn:normalize-space(xs:string(.))">
																		<xsl:variable name="var1917_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																		<gmd:voice>
																			<gco:CharacterString>
																				<xsl:sequence select="$var1917_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:voice>
																	</xsl:for-each-group>
																	<xsl:for-each-group select="cntfax" group-by="fn:normalize-space(xs:string(.))">
																		<xsl:variable name="var1921_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																		<gmd:facsimile>
																			<gco:CharacterString>
																				<xsl:sequence select="$var1921_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:facsimile>
																	</xsl:for-each-group>
																</gmd:CI_Telephone>
															</gmd:phone>
															<xsl:for-each select="cntaddr">
																<gmd:address>
																	<gmd:CI_Address>
																		<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																			<xsl:variable name="var1927_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																			<gmd:deliveryPoint>
																				<gco:CharacterString>
																					<xsl:sequence select="$var1927_cur_result_groupby"/>
																				</gco:CharacterString>
																			</gmd:deliveryPoint>
																		</xsl:for-each-group>
																		<xsl:for-each select="city">
																			<gmd:city>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:city>
																		</xsl:for-each>
																		<xsl:for-each select="state">
																			<gmd:administrativeArea>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:administrativeArea>
																		</xsl:for-each>
																		<xsl:for-each select="postal">
																			<gmd:postalCode>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:postalCode>
																		</xsl:for-each>
																		<xsl:for-each select="country">
																			<gmd:country>
																				<gco:CharacterString>
																					<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																				</gco:CharacterString>
																			</gmd:country>
																		</xsl:for-each>
																		<xsl:for-each-group select="$var1889_cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																			<xsl:variable name="var1939_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																			<gmd:electronicMailAddress>
																				<gco:CharacterString>
																					<xsl:sequence select="$var1939_cur_result_groupby"/>
																				</gco:CharacterString>
																			</gmd:electronicMailAddress>
																		</xsl:for-each-group>
																	</gmd:CI_Address>
																</gmd:address>
															</xsl:for-each>
															<xsl:for-each select="hours">
																<gmd:hoursOfService>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:hoursOfService>
															</xsl:for-each>
															<xsl:for-each select="cntinst">
																<gmd:contactInstructions>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:contactInstructions>
															</xsl:for-each>
														</gmd:CI_Contact>
													</gmd:contactInfo>
													<gmd:role>
														<xsl:variable name="var1945_cond_result_exists" as="xs:string?" select="(if (fn:exists(cntvoice)) then 'distributor' else ())"/>
														<xsl:if test="fn:exists($var1945_cond_result_exists)">
															<gmd:CI_RoleCode>
																<xsl:variable name="var1946_cond_result_exists" as="xs:string?" select="(if (fn:exists(cntvoice)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode' else ())"/>
																<xsl:if test="fn:exists($var1946_cond_result_exists)">
																	<xsl:attribute name="codeList">
																		<xsl:sequence select="xs:string(xs:anyURI($var1946_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:attribute name="codeListValue">
																	<xsl:sequence select="xs:string(xs:anyURI($var1945_cond_result_exists))"/>
																</xsl:attribute>
																<xsl:variable name="var1947_cond_result_exists" as="xs:string?" select="(if (fn:exists(cntvoice)) then '005' else ())"/>
																<xsl:if test="fn:exists($var1947_cond_result_exists)">
																	<xsl:attribute name="codeSpace">
																		<xsl:sequence select="xs:string(xs:anyURI($var1947_cond_result_exists))"/>
																	</xsl:attribute>
																</xsl:if>
																<xsl:sequence select="$var1945_cond_result_exists"/>
															</gmd:CI_RoleCode>
														</xsl:if>
													</gmd:role>
												</gmd:CI_ResponsibleParty>
											</gmd:distributorContact>
										</xsl:for-each>
										<xsl:for-each select="$var1852_distinfo/stdorder">
											<xsl:variable name="var1948_stdorder" as="node()" select="."/>
											<gmd:distributionOrderProcess>
												<gmd:MD_StandardOrderProcess>
													<xsl:for-each select="fees">
														<gmd:fees>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:fees>
													</xsl:for-each>
													<xsl:for-each select="$var1852_distinfo/availabl">
														<xsl:variable name="var1952_availabl" as="node()" select="."/>
														<gmd:plannedAvailableDateTime>
															<xsl:for-each select="timeinfo/sngdate/caldate">
																<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																	<xsl:attribute name="gco:nilReason">
																		<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																	</xsl:attribute>
																</xsl:if>
															</xsl:for-each>
															<xsl:for-each select="timeinfo/sngdate/caldate">
																<xsl:variable name="var1959_cond_result_logicalor" as="xs:string?">
																	<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																		<xsl:variable name="var1992_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(., '-')">
																						<xsl:if test="fn:ends-with(., '-')">
																							<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																								<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var1991_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var1992_map_result_distinctvalues)">
																				<xsl:variable name="var1997_cond_result_endswith" as="xs:string?">
																					<xsl:choose>
																						<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																								<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																									<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:sequence select="."/>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var1997_cond_result_endswith)">
																					<xsl:sequence select="$var1997_cond_result_endswith"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var1991_map_result_distinctvalues)">
																			<xsl:sequence select="xs:string(fn:string-join($var1991_map_result_distinctvalues, ' '))"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:variable>
																<xsl:for-each select="$var1959_cond_result_logicalor">
																	<xsl:variable name="var1960_cur_cond_result_logicalor" as="xs:string" select="."/>
																	<xsl:variable name="var1962_map_select_timeinfo" as="xs:string*">
																		<xsl:for-each select="$var1952_availabl/timeinfo/sngdate/time">
																			<xsl:variable name="var1989_result_vmf5_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf5_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:variable name="var1988_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var1989_result_vmf5_inputtoresult)) then (if (fn:contains($var1989_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																			<xsl:if test="not(fn:exists($var1988_cond_result_exists))">
																				<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:for-each select="fn:distinct-values($var1962_map_select_timeinfo)">
																		<xsl:variable name="var1967_cond_result_endswith" as="xs:string?">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., ':')">
																					<xsl:if test="fn:ends-with(., ':')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var1967_cond_result_endswith)">
																			<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var1967_cond_result_endswith)), 'Un'))">
																				<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var1967_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1967_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1967_cond_result_endswith))))) then 'T' else ()))">
																					<gco:DateTime>
																						<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var1960_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var1967_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var1967_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var1967_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var1967_cond_result_endswith))))))"/>
																					</gco:DateTime>
																				</xsl:if>
																			</xsl:if>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:for-each>
														</gmd:plannedAvailableDateTime>
													</xsl:for-each>
													<xsl:for-each select="ordering">
														<xsl:variable name="var2004_ordering" as="node()" select="."/>
														<gmd:orderingInstructions>
															<xsl:variable name="var2006_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var1948_stdorder/digform/digtopt/onlinopt/accinstr)">
																		<xsl:variable name="var2027_map_select_digform" as="xs:string*">
																			<xsl:for-each select="$var1948_stdorder/digform/digtopt/onlinopt/accinstr">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2027_map_select_digform)">
																			<xsl:sequence select="xs:string(fn:string-join($var2027_map_select_digform, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="' '"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var2006_cond_result_exists">
																<xsl:variable name="var2007_cur_cond_result_exists" as="xs:string" select="."/>
																<xsl:variable name="var2009_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="$var1948_stdorder/nondig">
																			<xsl:variable name="var2023_map_select_nondig" as="xs:string*">
																				<xsl:for-each select="$var1948_stdorder/nondig">
																					<xsl:sequence select="xs:string(.)"/>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2023_map_select_nondig)">
																				<xsl:sequence select="xs:string(fn:string-join($var2023_map_select_nondig, ' '))"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:sequence select="' '"/>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var2009_cond_result_exists">
																	<xsl:variable name="var2010_cur_cond_result_exists" as="xs:string" select="."/>
																	<xsl:variable name="var2012_cond_result_exists" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="$var1852_distinfo/custom">
																				<xsl:variable name="var2019_map_select_custom" as="xs:string*">
																					<xsl:for-each select="$var1852_distinfo/custom">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2019_map_select_custom)">
																					<xsl:sequence select="xs:string(fn:string-join($var2019_map_select_custom, ' '))"/>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="' '"/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var2012_cond_result_exists">
																		<gco:CharacterString>
																			<xsl:variable name="var2015_cond_result_exists" as="xs:string" select="(if (fn:exists($var1948_stdorder/digform/digtopt/onlinopt/accinstr)) then 'Access Instructions: ' else ' ')"/>
																			<xsl:variable name="var2016_cond_result_exists" as="xs:string" select="(if (fn:exists($var1948_stdorder/nondig)) then 'Non-Digital Form: ' else ' ')"/>
																			<xsl:variable name="var2017_cond_result_exists" as="xs:string" select="(if (fn:exists($var1852_distinfo/custom)) then ' Custom Order Process: ' else ' ')"/>
																			<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat($var2015_cond_result_exists, $var2007_cur_cond_result_exists), $var2016_cond_result_exists), ' '), $var2010_cur_cond_result_exists), ' '), 'Ordering Instructions: '), ' '), xs:string($var2004_ordering)), $var2017_cond_result_exists), .)))"/>
																		</gco:CharacterString>
																	</xsl:for-each>
																</xsl:for-each>
															</xsl:for-each>
														</gmd:orderingInstructions>
													</xsl:for-each>
													<xsl:for-each select="turnarnd">
														<gmd:turnaround>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:turnaround>
													</xsl:for-each>
												</gmd:MD_StandardOrderProcess>
											</gmd:distributionOrderProcess>
										</xsl:for-each>
									</gmd:MD_Distributor>
								</gmd:distributor>
							</xsl:for-each>
							<xsl:for-each-group select="stdorder/digform/digtopt/offoptn" group-by="grp:key1a17d0b8(.)">
								<xsl:variable name="var2035_cur_result_groupby" as="item()+" select="current-group()"/>
								<gmd:transferOptions>
									<gmd:MD_DigitalTransferOptions>
										<xsl:for-each select="$var1852_distinfo/stdorder/digform/digtinfo/transize">
											<gmd:transferSize>
												<gco:Real>
													<xsl:sequence select="xs:string(xs:double(.))"/>
												</gco:Real>
											</gmd:transferSize>
										</xsl:for-each>
										<xsl:variable name="var2045_map_select_stdorder" as="xs:string*">
											<xsl:for-each select="$var1852_distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:variable>
										<xsl:variable name="var2040_cond_result_exists" as="xs:string*">
											<xsl:choose>
												<xsl:when test="fn:exists($var2045_map_select_stdorder)">
													<xsl:for-each select="$var1852_distinfo/stdorder/digform/digtopt/onlinopt/computer/networka/networkr">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:when>
												<xsl:otherwise>
													<xsl:for-each select="$var1850_metadata/idinfo/citation/citeinfo/onlink">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="fn:distinct-values($var2040_cond_result_exists)">
											<gmd:onLine>
												<gmd:CI_OnlineResource>
													<gmd:linkage>
														<gmd:URL>
															<xsl:sequence select="xs:string(xs:anyURI(fn:normalize-space(.)))"/>
														</gmd:URL>
													</gmd:linkage>
													<xsl:for-each select="$var1852_distinfo/stdorder/digform/digtopt/onlinopt/oncomp">
														<gmd:description>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:description>
													</xsl:for-each>
												</gmd:CI_OnlineResource>
											</gmd:onLine>
										</xsl:for-each>
										<gmd:offLine>
											<gmd:MD_Medium>
												<gmd:name>
													<gmd:MD_MediumNameCode>
														<xsl:variable name="var2054_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($var2035_cur_result_groupby/offmedia)">
																	<xsl:variable name="var2059_map_result_groupitems" as="xs:string*">
																		<xsl:for-each select="$var2035_cur_result_groupby/offmedia">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2058_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var2059_map_result_groupitems)">
																			<xsl:variable name="var2062_result_vmf16_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf16_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(.)"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:sequence select="$var2062_result_vmf16_inputtoresult"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2058_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var2058_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:variable name="var2053_cond_result_exists" as="xs:string?">
															<xsl:if test="$var2054_cond_result_exists">
																<xsl:variable name="var2056_cond_result_exists" as="xs:string" select="(if (fn:exists($var2035_cur_result_groupby/offmedia)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode' else '')"/>
																<xsl:sequence select="$var2056_cond_result_exists"/>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var2053_cond_result_exists)">
															<xsl:attribute name="codeList">
																<xsl:sequence select="xs:string(xs:anyURI($var2053_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var2066_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($var2035_cur_result_groupby/offmedia)">
																	<xsl:variable name="var2077_map_result_groupitems" as="xs:string*">
																		<xsl:for-each select="$var2035_cur_result_groupby/offmedia">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2076_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var2077_map_result_groupitems)">
																			<xsl:variable name="var2080_result_vmf16_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf16_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(.)"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:sequence select="$var2080_result_vmf16_inputtoresult"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2076_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var2076_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:variable name="var2065_cond_result_exists" as="xs:string?">
															<xsl:if test="$var2066_cond_result_exists">
																<xsl:choose>
																	<xsl:when test="fn:exists($var2035_cur_result_groupby/offmedia)">
																		<xsl:variable name="var2069_map_result_groupitems" as="xs:string*">
																			<xsl:for-each select="$var2035_cur_result_groupby/offmedia">
																				<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2068_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var2069_map_result_groupitems)">
																				<xsl:variable name="var2072_result_vmf16_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf16_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(.)"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:sequence select="$var2072_result_vmf16_inputtoresult"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2068_map_result_distinctvalues)">
																			<xsl:sequence select="xs:string(fn:string-join($var2068_map_result_distinctvalues, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="''"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var2065_cond_result_exists)">
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI($var2065_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:variable name="var2084_cond_result_exists" as="xs:string?">
															<xsl:choose>
																<xsl:when test="fn:exists($var2035_cur_result_groupby/offmedia)">
																	<xsl:variable name="var2095_map_result_groupitems" as="xs:string*">
																		<xsl:for-each select="$var2035_cur_result_groupby/offmedia">
																			<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2094_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var2095_map_result_groupitems)">
																			<xsl:variable name="var2098_result_vmf16_inputtoresult" as="xs:string?">
																				<xsl:call-template name="vmf:vmf16_inputtoresult">
																					<xsl:with-param name="input" select="fn:upper-case(.)"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:sequence select="$var2098_result_vmf16_inputtoresult"/>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2094_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var2094_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="''"/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:variable name="var2083_cond_result_exists" as="xs:string?">
															<xsl:if test="$var2084_cond_result_exists">
																<xsl:choose>
																	<xsl:when test="fn:exists($var2035_cur_result_groupby/offmedia)">
																		<xsl:variable name="var2087_map_result_groupitems" as="xs:string*">
																			<xsl:for-each select="$var2035_cur_result_groupby/offmedia">
																				<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2086_map_result_distinctvalues" as="xs:string*">
																			<xsl:for-each select="fn:distinct-values($var2087_map_result_groupitems)">
																				<xsl:variable name="var2090_result_vmf17_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf17_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(.)"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:sequence select="$var2090_result_vmf17_inputtoresult"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2086_map_result_distinctvalues)">
																			<xsl:sequence select="xs:string(fn:string-join($var2086_map_result_distinctvalues, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="''"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:if>
														</xsl:variable>
														<xsl:if test="fn:exists($var2083_cond_result_exists)">
															<xsl:attribute name="codeSpace">
																<xsl:sequence select="xs:string(xs:anyURI($var2083_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<xsl:sequence select="''"/>
													</gmd:MD_MediumNameCode>
												</gmd:name>
												<xsl:for-each select="$var2035_cur_result_groupby/reccap/recden">
													<gmd:density>
														<gco:Real>
															<xsl:sequence select="xs:string(xs:double(.))"/>
														</gco:Real>
													</gmd:density>
												</xsl:for-each>
												<xsl:for-each select="$var2035_cur_result_groupby/reccap/recdenu">
													<gmd:densityUnits>
														<gco:CharacterString>
															<xsl:sequence select="xs:string(.)"/>
														</gco:CharacterString>
													</gmd:densityUnits>
												</xsl:for-each>
												<gmd:mediumFormat>
													<xsl:variable name="var2105_cond_result_exists" as="xs:string?">
														<xsl:choose>
															<xsl:when test="fn:exists($var2035_cur_result_groupby/recfmt)">
																<xsl:variable name="var2118_map_result_groupitems" as="xs:string*">
																	<xsl:for-each select="$var2035_cur_result_groupby/recfmt">
																		<xsl:variable name="var2121_result_vmf18_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf18_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2121_result_vmf18_inputtoresult)">
																			<xsl:sequence select="$var2121_result_vmf18_inputtoresult"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:if test="fn:exists($var2118_map_result_groupitems)">
																	<xsl:sequence select="xs:string(fn:string-join($var2118_map_result_groupitems, ' '))"/>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:sequence select="''"/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:for-each select="$var2105_cond_result_exists">
														<gmd:MD_MediumFormatCode>
															<xsl:attribute name="codeList">
																<xsl:variable name="var2108_cond_result_exists" as="xs:string" select="(if (fn:exists($var2035_cur_result_groupby/recfmt)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode' else '')"/>
																<xsl:sequence select="xs:string(xs:anyURI($var2108_cond_result_exists))"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:sequence select="xs:string(xs:anyURI(.))"/>
															</xsl:attribute>
															<xsl:variable name="var2109_cond_result_exists" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:exists($var2035_cur_result_groupby/recfmt)">
																		<xsl:variable name="var2113_map_result_groupitems" as="xs:string*">
																			<xsl:for-each select="$var2035_cur_result_groupby/recfmt">
																				<xsl:variable name="var2116_result_vmf19_inputtoresult" as="xs:string?">
																					<xsl:call-template name="vmf:vmf19_inputtoresult">
																						<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																					</xsl:call-template>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2116_result_vmf19_inputtoresult)">
																					<xsl:sequence select="$var2116_result_vmf19_inputtoresult"/>
																				</xsl:if>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:if test="fn:exists($var2113_map_result_groupitems)">
																			<xsl:sequence select="xs:string(fn:string-join($var2113_map_result_groupitems, ' '))"/>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="''"/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:for-each select="$var2109_cond_result_exists">
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																</xsl:attribute>
															</xsl:for-each>
															<xsl:sequence select="."/>
														</gmd:MD_MediumFormatCode>
													</xsl:for-each>
												</gmd:mediumFormat>
												<xsl:variable name="var2122_cond_result_exists" as="xs:string?" select="(if (fn:exists($var1852_distinfo/stdorder/digform/digtinfo/formcont)) then 'Format Information Content:  ' else ())"/>
												<xsl:if test="fn:exists($var2122_cond_result_exists)">
													<xsl:for-each select="$var1852_distinfo/stdorder/digform/digtinfo/formcont">
														<xsl:variable name="var2123_formcont" as="node()" select="."/>
														<xsl:variable name="var2125_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2035_cur_result_groupby/compat)) then ' Compatibility Information: ' else ())"/>
														<xsl:if test="fn:exists($var2125_cond_result_exists)">
															<xsl:for-each select="$var2035_cur_result_groupby/compat">
																<gmd:mediumNote>
																	<gco:CharacterString>
																		<xsl:sequence select="fn:concat(fn:concat(fn:concat($var2122_cond_result_exists, fn:normalize-space(xs:string($var2123_formcont))), $var2125_cond_result_exists), xs:string(.))"/>
																	</gco:CharacterString>
																</gmd:mediumNote>
															</xsl:for-each>
														</xsl:if>
													</xsl:for-each>
												</xsl:if>
											</gmd:MD_Medium>
										</gmd:offLine>
									</gmd:MD_DigitalTransferOptions>
								</gmd:transferOptions>
							</xsl:for-each-group>
						</gmd:MD_Distribution>
					</gmd:distributionInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata">
				<xsl:variable name="var2128_metadata" as="node()" select="."/>
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string('unknown'))"/>
								</xsl:attribute>
							</gmd:scope>
							<xsl:for-each select="posacc">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<xsl:variable name="var2134_cond_result_exists" as="xs:string?" select="(if (fn:exists(horizpa/horizpar)) then 'Horizontal Positional Accuracy' else ())"/>
											<xsl:if test="fn:exists($var2134_cond_result_exists)">
												<gco:CharacterString>
													<xsl:sequence select="$var2134_cond_result_exists"/>
												</gco:CharacterString>
											</xsl:if>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="horizpa/qhorizpa/horizpae">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<xsl:for-each select="horizpa/horizpar">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:variable name="var2139_cond_result_exists" as="xs:string?" select="(if (fn:exists(horizpa/horizpar)) then 'meters' else ())"/>
														<xsl:if test="fn:exists($var2139_cond_result_exists)">
															<xsl:attribute name="gml:id">
																<xsl:sequence select="xs:string(xs:ID($var2139_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<gml:identifier>
															<xsl:variable name="var2140_cond_result_exists" as="xs:string?" select="(if (fn:exists(horizpa/horizpar)) then 'meters' else ())"/>
															<xsl:if test="fn:exists($var2140_cond_result_exists)">
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI($var2140_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:variable name="var2141_cond_result_exists" as="xs:string?" select="(if (fn:exists(horizpa/horizpar)) then 'http://www.bipm.org/en/si/' else ())"/>
															<xsl:if test="fn:exists($var2141_cond_result_exists)">
																<xsl:attribute name="xlink:href">
																	<xsl:sequence select="xs:string(xs:anyURI($var2141_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="horizpa/qhorizpa/horizpav">
														<gco:Record>
															<xsl:sequence select="xs:string(xs:double(.))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="posacc">
								<gmd:report>
									<gmd:DQ_AbsoluteExternalPositionalAccuracy>
										<gmd:nameOfMeasure>
											<xsl:variable name="var2146_cond_result_exists" as="xs:string?" select="(if (fn:exists(vertacc/vertaccr)) then 'Vertical Positional Accuracy' else ())"/>
											<xsl:if test="fn:exists($var2146_cond_result_exists)">
												<gco:CharacterString>
													<xsl:sequence select="$var2146_cond_result_exists"/>
												</gco:CharacterString>
											</xsl:if>
										</gmd:nameOfMeasure>
										<gmd:measureDescription>
											<xsl:for-each select="vertacc/qvertpa/vertacce">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:measureDescription>
										<gmd:evaluationMethodDescription>
											<xsl:for-each select="vertacc/vertaccr">
												<gco:CharacterString>
													<xsl:sequence select="xs:string(.)"/>
												</gco:CharacterString>
											</xsl:for-each>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<gmd:DQ_QuantitativeResult>
												<gmd:valueUnit>
													<gml:BaseUnit>
														<xsl:variable name="var2151_cond_result_exists" as="xs:string?" select="(if (fn:exists(vertacc/vertaccr)) then 'meters' else ())"/>
														<xsl:if test="fn:exists($var2151_cond_result_exists)">
															<xsl:attribute name="gml:id">
																<xsl:sequence select="xs:string(xs:ID($var2151_cond_result_exists))"/>
															</xsl:attribute>
														</xsl:if>
														<gml:identifier>
															<xsl:variable name="var2152_cond_result_exists" as="xs:string?" select="(if (fn:exists(vertacc/vertaccr)) then 'meters' else ())"/>
															<xsl:if test="fn:exists($var2152_cond_result_exists)">
																<xsl:attribute name="codeSpace">
																	<xsl:sequence select="xs:string(xs:anyURI($var2152_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
														</gml:identifier>
														<gml:unitsSystem>
															<xsl:variable name="var2153_cond_result_exists" as="xs:string?" select="(if (fn:exists(vertacc/vertaccr)) then 'http://www.bipm.org/en/si/' else ())"/>
															<xsl:if test="fn:exists($var2153_cond_result_exists)">
																<xsl:attribute name="xlink:href">
																	<xsl:sequence select="xs:string(xs:anyURI($var2153_cond_result_exists))"/>
																</xsl:attribute>
															</xsl:if>
														</gml:unitsSystem>
													</gml:BaseUnit>
												</gmd:valueUnit>
												<gmd:value>
													<xsl:for-each select="vertacc/qvertpa/vertaccv">
														<gco:Record>
															<xsl:sequence select="xs:string(xs:double(.))"/>
														</gco:Record>
													</xsl:for-each>
												</gmd:value>
											</gmd:DQ_QuantitativeResult>
										</gmd:result>
									</gmd:DQ_AbsoluteExternalPositionalAccuracy>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="complete">
								<gmd:report>
									<gmd:DQ_CompletenessCommission>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(.)"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string('unknown'))"/>
											</xsl:attribute>
										</gmd:result>
									</gmd:DQ_CompletenessCommission>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="complete">
								<gmd:report>
									<gmd:DQ_CompletenessOmission>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(.)"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
											<xsl:variable name="var2160_cond_result_exists" as="xs:decimal" select="(if (fn:exists($var2128_metadata/eainfo/detailed)) then xs:decimal(1) else xs:decimal(0))"/>
											<xsl:if test="fn:exists((if ((xs:string($var2160_cond_result_exists) = 'false')) then () else 'unknown'))">
												<xsl:attribute name="gco:nilReason">
													<xsl:sequence select="xs:string(xs:string((if ((xs:string($var2160_cond_result_exists) = 'false')) then () else 'unknown')))"/>
												</xsl:attribute>
											</xsl:if>
										</gmd:result>
									</gmd:DQ_CompletenessOmission>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="logic">
								<gmd:report>
									<gmd:DQ_ConceptualConsistency>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:sequence select="xs:string(.)"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason">
												<xsl:sequence select="xs:string(xs:string('unknown'))"/>
											</xsl:attribute>
										</gmd:result>
									</gmd:DQ_ConceptualConsistency>
								</gmd:report>
							</xsl:for-each>
							<xsl:for-each select="attracc">
								<xsl:variable name="var2163_attracc" as="node()" select="."/>
								<xsl:for-each select="qattracc">
									<xsl:variable name="var2165_qattracc" as="node()" select="."/>
									<gmd:report>
										<gmd:DQ_QuantitativeAttributeAccuracy>
											<gmd:nameOfMeasure>
												<xsl:variable name="var2167_cond_result_exists" as="xs:string?" select="(if (fn:exists(attraccv)) then 'Quantitative Attribute Accuracy Assessment' else ())"/>
												<xsl:if test="fn:exists($var2167_cond_result_exists)">
													<gco:CharacterString>
														<xsl:sequence select="$var2167_cond_result_exists"/>
													</gco:CharacterString>
												</xsl:if>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<xsl:for-each select="attracce">
													<gco:CharacterString>
														<xsl:sequence select="xs:string(.)"/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<xsl:variable name="var2173_map_select_attraccr" as="xs:string*">
													<xsl:for-each select="$var2163_attracc/attraccr">
														<xsl:sequence select="xs:string(.)"/>
													</xsl:for-each>
												</xsl:variable>
												<xsl:variable name="var2170_cond_result_exists" as="xs:string*">
													<xsl:choose>
														<xsl:when test="fn:exists($var2173_map_select_attraccr)">
															<xsl:for-each select="$var2163_attracc/attraccr">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:when>
														<xsl:otherwise>
															<xsl:for-each select="$var2128_metadata/eainfo/detailed/attr/attrvai/attrvae">
																<xsl:sequence select="xs:string(.)"/>
															</xsl:for-each>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:variable>
												<xsl:for-each select="$var2170_cond_result_exists">
													<gco:CharacterString>
														<xsl:sequence select="."/>
													</gco:CharacterString>
												</xsl:for-each>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:value>
														<xsl:variable name="var2184_map_select_attraccv" as="xs:string*">
															<xsl:for-each select="attraccv">
																<xsl:sequence select="xs:string(xs:string(.))"/>
															</xsl:for-each>
														</xsl:variable>
														<xsl:variable name="var2181_cond_result_exists" as="xs:string*">
															<xsl:choose>
																<xsl:when test="fn:exists($var2184_map_select_attraccv)">
																	<xsl:for-each select="attraccv">
																		<xsl:sequence select="xs:string(xs:string(.))"/>
																	</xsl:for-each>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:for-each select="$var2128_metadata/eainfo/detailed/attr/attrvai/attrva">
																		<xsl:sequence select="xs:string(xs:double(.))"/>
																	</xsl:for-each>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:variable>
														<xsl:for-each select="$var2181_cond_result_exists">
															<gco:Record>
																<xsl:sequence select="."/>
															</gco:Record>
														</xsl:for-each>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_QuantitativeAttributeAccuracy>
									</gmd:report>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="lineage">
								<gmd:lineage>
									<gmd:LI_Lineage>
										<xsl:for-each select="procstep">
											<xsl:variable name="var2194_procstep" as="node()" select="."/>
											<gmd:processStep>
												<gmd:LI_ProcessStep>
													<gmd:description>
														<xsl:for-each select="procdesc">
															<gco:CharacterString>
																<xsl:sequence select="xs:string(.)"/>
															</gco:CharacterString>
														</xsl:for-each>
													</gmd:description>
													<gmd:dateTime>
														<xsl:for-each select="procdate">
															<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																<xsl:attribute name="gco:nilReason">
																	<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																</xsl:attribute>
															</xsl:if>
														</xsl:for-each>
														<xsl:for-each select="procdate">
															<xsl:variable name="var2203_cond_result_logicalor" as="xs:string?">
																<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																	<xsl:variable name="var2236_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																			<xsl:choose>
																				<xsl:when test="fn:ends-with(., '-')">
																					<xsl:if test="fn:ends-with(., '-')">
																						<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																							<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																						</xsl:if>
																					</xsl:if>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:sequence select="."/>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:variable name="var2235_map_result_distinctvalues" as="xs:string*">
																		<xsl:for-each select="fn:distinct-values($var2236_map_result_distinctvalues)">
																			<xsl:variable name="var2241_cond_result_endswith" as="xs:string?">
																				<xsl:choose>
																					<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																						<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																								<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																							</xsl:if>
																						</xsl:if>
																					</xsl:when>
																					<xsl:otherwise>
																						<xsl:sequence select="."/>
																					</xsl:otherwise>
																				</xsl:choose>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2241_cond_result_endswith)">
																				<xsl:sequence select="$var2241_cond_result_endswith"/>
																			</xsl:if>
																		</xsl:for-each>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2235_map_result_distinctvalues)">
																		<xsl:sequence select="xs:string(fn:string-join($var2235_map_result_distinctvalues, ' '))"/>
																	</xsl:if>
																</xsl:if>
															</xsl:variable>
															<xsl:for-each select="$var2203_cond_result_logicalor">
																<xsl:variable name="var2204_cur_cond_result_logicalor" as="xs:string" select="."/>
																<xsl:variable name="var2206_map_select_proctime" as="xs:string*">
																	<xsl:for-each select="$var2194_procstep/proctime">
																		<xsl:variable name="var2233_result_vmf5_inputtoresult" as="xs:string?">
																			<xsl:call-template name="vmf:vmf5_inputtoresult">
																				<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																			</xsl:call-template>
																		</xsl:variable>
																		<xsl:variable name="var2232_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2233_result_vmf5_inputtoresult)) then (if (fn:contains($var2233_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																		<xsl:if test="not(fn:exists($var2232_cond_result_exists))">
																			<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																		</xsl:if>
																	</xsl:for-each>
																</xsl:variable>
																<xsl:for-each select="fn:distinct-values($var2206_map_select_proctime)">
																	<xsl:variable name="var2211_cond_result_endswith" as="xs:string?">
																		<xsl:choose>
																			<xsl:when test="fn:ends-with(., ':')">
																				<xsl:if test="fn:ends-with(., ':')">
																					<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																						<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:sequence select="."/>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:if test="fn:exists($var2211_cond_result_endswith)">
																		<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2211_cond_result_endswith)), 'Un'))">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2211_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2211_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2211_cond_result_endswith))))) then 'T' else ()))">
																				<gco:DateTime>
																					<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2204_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2211_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2211_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2211_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2211_cond_result_endswith)))))))"/>
																				</gco:DateTime>
																			</xsl:if>
																		</xsl:if>
																	</xsl:if>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:for-each>
													</gmd:dateTime>
													<xsl:for-each select="proccont">
														<gmd:processor>
															<xsl:for-each select="cntinfo">
																<xsl:variable name="var2250_cntinfo" as="node()" select="."/>
																<gmd:CI_ResponsibleParty>
																	<gmd:individualName>
																		<xsl:variable name="var2255_map_select_cntperp" as="xs:string*">
																			<xsl:for-each select="cntperp/cntper">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2252_cond_result_exists" as="xs:string*">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var2255_map_select_cntperp)">
																					<xsl:for-each select="cntperp/cntper">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntorgp/cntper">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:for-each select="$var2252_cond_result_exists">
																			<gco:CharacterString>
																				<xsl:sequence select="."/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:individualName>
																	<gmd:organisationName>
																		<xsl:variable name="var2266_map_select_cntperp" as="xs:string*">
																			<xsl:for-each select="cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2263_cond_result_exists" as="xs:string*">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var2266_map_select_cntperp)">
																					<xsl:for-each select="cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:for-each select="$var2263_cond_result_exists">
																			<gco:CharacterString>
																				<xsl:sequence select="."/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:organisationName>
																	<gmd:positionName>
																		<xsl:for-each select="cntpos">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:positionName>
																	<gmd:contactInfo>
																		<gmd:CI_Contact>
																			<gmd:phone>
																				<gmd:CI_Telephone>
																					<xsl:for-each-group select="cntvoice" group-by="fn:normalize-space(xs:string(.))">
																						<xsl:variable name="var2278_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																						<gmd:voice>
																							<gco:CharacterString>
																								<xsl:sequence select="$var2278_cur_result_groupby"/>
																							</gco:CharacterString>
																						</gmd:voice>
																					</xsl:for-each-group>
																					<xsl:for-each-group select="cntfax" group-by="fn:normalize-space(xs:string(.))">
																						<xsl:variable name="var2282_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																						<gmd:facsimile>
																							<gco:CharacterString>
																								<xsl:sequence select="$var2282_cur_result_groupby"/>
																							</gco:CharacterString>
																						</gmd:facsimile>
																					</xsl:for-each-group>
																				</gmd:CI_Telephone>
																			</gmd:phone>
																			<xsl:for-each select="cntaddr">
																				<gmd:address>
																					<gmd:CI_Address>
																						<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
																							<xsl:variable name="var2288_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																							<gmd:deliveryPoint>
																								<gco:CharacterString>
																									<xsl:sequence select="$var2288_cur_result_groupby"/>
																								</gco:CharacterString>
																							</gmd:deliveryPoint>
																						</xsl:for-each-group>
																						<gmd:city>
																							<xsl:for-each select="city">
																								<gco:CharacterString>
																									<xsl:sequence select="xs:string(.)"/>
																								</gco:CharacterString>
																							</xsl:for-each>
																						</gmd:city>
																						<gmd:administrativeArea>
																							<xsl:for-each select="state">
																								<gco:CharacterString>
																									<xsl:sequence select="xs:string(.)"/>
																								</gco:CharacterString>
																							</xsl:for-each>
																						</gmd:administrativeArea>
																						<gmd:postalCode>
																							<xsl:for-each select="postal">
																								<gco:CharacterString>
																									<xsl:sequence select="xs:string(.)"/>
																								</gco:CharacterString>
																							</xsl:for-each>
																						</gmd:postalCode>
																						<gmd:country>
																							<xsl:for-each select="country">
																								<gco:CharacterString>
																									<xsl:sequence select="xs:string(.)"/>
																								</gco:CharacterString>
																							</xsl:for-each>
																						</gmd:country>
																						<xsl:for-each-group select="$var2250_cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
																							<xsl:variable name="var2300_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																							<gmd:electronicMailAddress>
																								<gco:CharacterString>
																									<xsl:sequence select="$var2300_cur_result_groupby"/>
																								</gco:CharacterString>
																							</gmd:electronicMailAddress>
																						</xsl:for-each-group>
																					</gmd:CI_Address>
																				</gmd:address>
																			</xsl:for-each>
																			<gmd:hoursOfService>
																				<xsl:for-each select="hours">
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(.)"/>
																					</gco:CharacterString>
																				</xsl:for-each>
																			</gmd:hoursOfService>
																			<gmd:contactInstructions>
																				<xsl:for-each select="cntinst">
																					<gco:CharacterString>
																						<xsl:sequence select="xs:string(.)"/>
																					</gco:CharacterString>
																				</xsl:for-each>
																			</gmd:contactInstructions>
																		</gmd:CI_Contact>
																	</gmd:contactInfo>
																	<gmd:role>
																		<xsl:variable name="var2328_map_select_cntperp" as="xs:string*">
																			<xsl:for-each select="cntperp/cntorg">
																				<xsl:sequence select="xs:string(.)"/>
																			</xsl:for-each>
																		</xsl:variable>
																		<xsl:variable name="var2327_cond_result_exists" as="xs:string*">
																			<xsl:choose>
																				<xsl:when test="fn:exists($var2328_map_select_cntperp)">
																					<xsl:for-each select="cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:when>
																				<xsl:otherwise>
																					<xsl:for-each select="cntorgp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:variable>
																		<xsl:variable name="var2306_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2327_cond_result_exists)) then 'processor' else ())"/>
																		<xsl:if test="fn:exists($var2306_cond_result_exists)">
																			<gmd:CI_RoleCode>
																				<xsl:variable name="var2309_map_select_cntperp" as="xs:string*">
																					<xsl:for-each select="cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2308_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2309_map_select_cntperp)">
																							<xsl:for-each select="cntperp/cntorg">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="cntorgp/cntorg">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:variable name="var2307_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2308_cond_result_exists)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode' else ())"/>
																				<xsl:if test="fn:exists($var2307_cond_result_exists)">
																					<xsl:attribute name="codeList">
																						<xsl:sequence select="xs:string(xs:anyURI($var2307_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:attribute name="codeListValue">
																					<xsl:sequence select="xs:string(xs:anyURI($var2306_cond_result_exists))"/>
																				</xsl:attribute>
																				<xsl:variable name="var2319_map_select_cntperp" as="xs:string*">
																					<xsl:for-each select="cntperp/cntorg">
																						<xsl:sequence select="xs:string(.)"/>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2318_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2319_map_select_cntperp)">
																							<xsl:for-each select="cntperp/cntorg">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="cntorgp/cntorg">
																								<xsl:sequence select="xs:string(.)"/>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:variable name="var2317_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2318_cond_result_exists)) then '009' else ())"/>
																				<xsl:if test="fn:exists($var2317_cond_result_exists)">
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI($var2317_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:sequence select="$var2306_cond_result_exists"/>
																			</gmd:CI_RoleCode>
																		</xsl:if>
																	</gmd:role>
																</gmd:CI_ResponsibleParty>
															</xsl:for-each>
														</gmd:processor>
													</xsl:for-each>
													<xsl:for-each-group select="." group-by="grp:key19e65b10(.)">
														<xsl:variable name="var2339_cur_result_groupby" as="item()+" select="current-group()"/>
														<xsl:variable name="var2340_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:source>
															<gmd:LI_Source>
																<gmd:sourceCitation>
																	<gmd:CI_Citation>
																		<gmd:title>
																			<gco:CharacterString>
																				<xsl:sequence select="$var2340_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:title>
																		<xsl:for-each select="$var2339_cur_result_groupby/srcprod">
																			<gmd:alternateTitle>
																				<gco:CharacterString>
																					<xsl:sequence select="xs:string(.)"/>
																				</gco:CharacterString>
																			</gmd:alternateTitle>
																		</xsl:for-each>
																		<gmd:date>
																			<xsl:attribute name="gco:nilReason">
																				<xsl:sequence select="xs:string(xs:string('unknown'))"/>
																			</xsl:attribute>
																		</gmd:date>
																	</gmd:CI_Citation>
																</gmd:sourceCitation>
															</gmd:LI_Source>
														</gmd:source>
													</xsl:for-each-group>
												</gmd:LI_ProcessStep>
											</gmd:processStep>
										</xsl:for-each>
										<xsl:for-each select="srcinfo">
											<xsl:variable name="var2344_srcinfo" as="node()" select="."/>
											<gmd:source>
												<gmd:LI_Source>
													<gmd:description>
														<xsl:variable name="var2346_cond_result_exists" as="xs:string?" select="(if (fn:exists(srccontr)) then 'Source Contribution: ' else ())"/>
														<xsl:if test="fn:exists($var2346_cond_result_exists)">
															<xsl:for-each select="srccontr">
																<xsl:variable name="var2347_srccontr" as="node()" select="."/>
																<xsl:for-each select="$var2344_srcinfo/typesrc">
																	<gco:CharacterString>
																		<xsl:sequence select="fn:concat(fn:concat($var2346_cond_result_exists, xs:string($var2347_srccontr)), xs:string(xs:string(.)))"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</xsl:for-each>
														</xsl:if>
													</gmd:description>
													<gmd:scaleDenominator>
														<gmd:MD_RepresentativeFraction>
															<gmd:denominator>
																<xsl:for-each select="srcscale">
																	<xsl:if test="(fn:lower-case(fn:string(.)) = 'unknown')">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:sequence select="xs:string(xs:string(fn:string(.)))"/>
																		</xsl:attribute>
																	</xsl:if>
																</xsl:for-each>
																<xsl:for-each select="srcscale">
																	<xsl:if test="not((fn:lower-case(fn:string(.)) = 'unknown'))">
																		<gco:Integer>
																			<xsl:sequence select="xs:string(xs:integer(.))"/>
																		</gco:Integer>
																	</xsl:if>
																</xsl:for-each>
															</gmd:denominator>
														</gmd:MD_RepresentativeFraction>
													</gmd:scaleDenominator>
													<gmd:sourceCitation>
														<gmd:CI_Citation>
															<gmd:title>
																<xsl:for-each select="srccite/citeinfo/title">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:title>
															<xsl:for-each select="srccitea">
																<gmd:alternateTitle>
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</gmd:alternateTitle>
															</xsl:for-each>
															<gmd:date>
																<gmd:CI_Date>
																	<gmd:date>
																		<xsl:for-each select="srccite/citeinfo/pubdate">
																			<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																				<xsl:attribute name="gco:nilReason">
																					<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																				</xsl:attribute>
																			</xsl:if>
																		</xsl:for-each>
																		<xsl:for-each select="srccite/citeinfo/pubdate">
																			<xsl:variable name="var2364_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var2369_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2368_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2369_map_result_distinctvalues)">
																							<xsl:variable name="var2374_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2374_cond_result_endswith)">
																								<xsl:sequence select="$var2374_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2368_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var2368_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var2364_cond_result_logicalor">
																				<gco:Date>
																					<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
																				</gco:Date>
																			</xsl:for-each>
																		</xsl:for-each>
																		<xsl:for-each select="srccite/citeinfo/pubdate">
																			<xsl:variable name="var2384_cond_result_logicalor" as="xs:string?">
																				<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																					<xsl:variable name="var2417_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																							<xsl:choose>
																								<xsl:when test="fn:ends-with(., '-')">
																									<xsl:if test="fn:ends-with(., '-')">
																										<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																											<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:sequence select="."/>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2416_map_result_distinctvalues" as="xs:string*">
																						<xsl:for-each select="fn:distinct-values($var2417_map_result_distinctvalues)">
																							<xsl:variable name="var2422_cond_result_endswith" as="xs:string?">
																								<xsl:choose>
																									<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																										<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																												<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="."/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:variable>
																							<xsl:if test="fn:exists($var2422_cond_result_endswith)">
																								<xsl:sequence select="$var2422_cond_result_endswith"/>
																							</xsl:if>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2416_map_result_distinctvalues)">
																						<xsl:sequence select="xs:string(fn:string-join($var2416_map_result_distinctvalues, ' '))"/>
																					</xsl:if>
																				</xsl:if>
																			</xsl:variable>
																			<xsl:for-each select="$var2384_cond_result_logicalor">
																				<xsl:variable name="var2385_cur_cond_result_logicalor" as="xs:string" select="."/>
																				<xsl:variable name="var2387_map_select_srccite" as="xs:string*">
																					<xsl:for-each select="$var2344_srcinfo/srccite/citeinfo/pubtime">
																						<xsl:variable name="var2414_result_vmf5_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf5_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:variable name="var2413_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2414_result_vmf5_inputtoresult)) then (if (fn:contains($var2414_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																						<xsl:if test="not(fn:exists($var2413_cond_result_exists))">
																							<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:for-each select="fn:distinct-values($var2387_map_select_srccite)">
																					<xsl:variable name="var2392_cond_result_endswith" as="xs:string?">
																						<xsl:choose>
																							<xsl:when test="fn:ends-with(., ':')">
																								<xsl:if test="fn:ends-with(., ':')">
																									<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																										<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:sequence select="."/>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2392_cond_result_endswith)">
																						<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2392_cond_result_endswith)), 'Un'))">
																							<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2392_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2392_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2392_cond_result_endswith))))) then 'T' else ()))">
																								<gco:DateTime>
																									<xsl:sequence select="xs:string(xs:dateTime(fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2385_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2392_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2392_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2392_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2392_cond_result_endswith))))))"/>
																								</gco:DateTime>
																							</xsl:if>
																						</xsl:if>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:for-each>
																		</xsl:for-each>
																	</gmd:date>
																	<gmd:dateType>
																		<xsl:variable name="var2429_cond_result_exists" as="xs:string?" select="(if (fn:exists(srccite/citeinfo/pubdate)) then 'publication' else ())"/>
																		<xsl:if test="fn:exists($var2429_cond_result_exists)">
																			<gmd:CI_DateTypeCode>
																				<xsl:variable name="var2430_cond_result_exists" as="xs:string?" select="(if (fn:exists(srccite/citeinfo/pubdate)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode' else ())"/>
																				<xsl:if test="fn:exists($var2430_cond_result_exists)">
																					<xsl:attribute name="codeList">
																						<xsl:sequence select="xs:string(xs:anyURI($var2430_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:attribute name="codeListValue">
																					<xsl:sequence select="xs:string(xs:anyURI($var2429_cond_result_exists))"/>
																				</xsl:attribute>
																				<xsl:variable name="var2431_cond_result_exists" as="xs:string?" select="(if (fn:exists(srccite/citeinfo/pubdate)) then '002' else ())"/>
																				<xsl:if test="fn:exists($var2431_cond_result_exists)">
																					<xsl:attribute name="codeSpace">
																						<xsl:sequence select="xs:string(xs:anyURI($var2431_cond_result_exists))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<xsl:sequence select="$var2429_cond_result_exists"/>
																			</gmd:CI_DateTypeCode>
																		</xsl:if>
																	</gmd:dateType>
																</gmd:CI_Date>
															</gmd:date>
															<gmd:edition>
																<xsl:for-each select="srccite/citeinfo/edition">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:edition>
															<xsl:for-each-group select="srccite/citeinfo" group-by="grp:key18d59618(.)">
																<xsl:variable name="var2437_cur_result_groupby" as="item()+" select="current-group()"/>
																<xsl:variable name="var2438_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
																<gmd:citedResponsibleParty>
																	<gmd:CI_ResponsibleParty>
																		<gmd:organisationName>
																			<gco:CharacterString>
																				<xsl:sequence select="$var2438_cur_result_groupby"/>
																			</gco:CharacterString>
																		</gmd:organisationName>
																		<gmd:role>
																			<xsl:variable name="var2440_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2437_cur_result_groupby/origin)) then 'resourceProvider' else ())"/>
																			<xsl:if test="fn:exists($var2440_cond_result_exists)">
																				<gmd:CI_RoleCode>
																					<xsl:variable name="var2441_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2437_cur_result_groupby/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode' else ())"/>
																					<xsl:if test="fn:exists($var2441_cond_result_exists)">
																						<xsl:attribute name="codeList">
																							<xsl:sequence select="xs:string(xs:anyURI($var2441_cond_result_exists))"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:attribute name="codeListValue">
																						<xsl:sequence select="xs:string(xs:anyURI($var2440_cond_result_exists))"/>
																					</xsl:attribute>
																					<xsl:variable name="var2442_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2437_cur_result_groupby/origin)) then '001' else ())"/>
																					<xsl:if test="fn:exists($var2442_cond_result_exists)">
																						<xsl:attribute name="codeSpace">
																							<xsl:sequence select="xs:string(xs:anyURI($var2442_cond_result_exists))"/>
																						</xsl:attribute>
																					</xsl:if>
																					<xsl:sequence select="$var2440_cond_result_exists"/>
																				</gmd:CI_RoleCode>
																			</xsl:if>
																		</gmd:role>
																	</gmd:CI_ResponsibleParty>
																</gmd:citedResponsibleParty>
															</xsl:for-each-group>
															<gmd:presentationForm>
																<xsl:variable name="var2443_cond_result_exists" as="xs:string?">
																	<xsl:choose>
																		<xsl:when test="fn:exists(srccite/citeinfo/geoform)">
																			<xsl:variable name="var2457_map_select_srccite" as="xs:string*">
																				<xsl:for-each select="srccite/citeinfo/geoform">
																					<xsl:variable name="var2460_result_vmf6_inputtoresult" as="xs:string?">
																						<xsl:call-template name="vmf:vmf6_inputtoresult">
																							<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																						</xsl:call-template>
																					</xsl:variable>
																					<xsl:if test="fn:exists($var2460_result_vmf6_inputtoresult)">
																						<xsl:sequence select="$var2460_result_vmf6_inputtoresult"/>
																					</xsl:if>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2457_map_select_srccite)">
																				<xsl:sequence select="xs:string(fn:string-join($var2457_map_select_srccite, ' '))"/>
																			</xsl:if>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:variable name="var2461_map_select_srccite" as="xs:string*">
																				<xsl:for-each select="srccite/citeinfo/geoform">
																					<xsl:sequence select="fn:normalize-space(xs:string(xs:string(.)))"/>
																				</xsl:for-each>
																			</xsl:variable>
																			<xsl:if test="fn:exists($var2461_map_select_srccite)">
																				<xsl:sequence select="xs:string(fn:string-join($var2461_map_select_srccite, ' '))"/>
																			</xsl:if>
																		</xsl:otherwise>
																	</xsl:choose>
																</xsl:variable>
																<xsl:for-each select="$var2443_cond_result_exists">
																	<gmd:CI_PresentationFormCode>
																		<xsl:variable name="var2446_cond_result_exists" as="xs:string?" select="(if (fn:exists($var2344_srcinfo/srccite/citeinfo/geoform)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode' else ())"/>
																		<xsl:if test="fn:exists($var2446_cond_result_exists)">
																			<xsl:attribute name="codeList">
																				<xsl:sequence select="xs:string(xs:anyURI($var2446_cond_result_exists))"/>
																			</xsl:attribute>
																		</xsl:if>
																		<xsl:attribute name="codeListValue">
																			<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																		</xsl:attribute>
																		<xsl:variable name="var2447_cond_result_exists" as="xs:string?">
																			<xsl:if test="fn:exists($var2344_srcinfo/srccite/citeinfo/geoform)">
																				<xsl:variable name="var2451_map_select_srccite" as="xs:string*">
																					<xsl:for-each select="$var2344_srcinfo/srccite/citeinfo/geoform">
																						<xsl:variable name="var2454_result_vmf7_inputtoresult" as="xs:string?">
																							<xsl:call-template name="vmf:vmf7_inputtoresult">
																								<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																							</xsl:call-template>
																						</xsl:variable>
																						<xsl:if test="fn:exists($var2454_result_vmf7_inputtoresult)">
																							<xsl:sequence select="$var2454_result_vmf7_inputtoresult"/>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:if test="fn:exists($var2451_map_select_srccite)">
																					<xsl:sequence select="xs:string(fn:string-join($var2451_map_select_srccite, ' '))"/>
																				</xsl:if>
																			</xsl:if>
																		</xsl:variable>
																		<xsl:for-each select="$var2447_cond_result_exists">
																			<xsl:attribute name="codeSpace">
																				<xsl:sequence select="xs:string(xs:anyURI(.))"/>
																			</xsl:attribute>
																		</xsl:for-each>
																		<xsl:sequence select="."/>
																	</gmd:CI_PresentationFormCode>
																</xsl:for-each>
															</gmd:presentationForm>
															<gmd:series>
																<gmd:CI_Series>
																	<gmd:name>
																		<xsl:for-each select="srccite/citeinfo/serinfo/sername">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:name>
																	<gmd:issueIdentification>
																		<xsl:for-each select="srccite/citeinfo/serinfo/issue">
																			<gco:CharacterString>
																				<xsl:sequence select="xs:string(.)"/>
																			</gco:CharacterString>
																		</xsl:for-each>
																	</gmd:issueIdentification>
																</gmd:CI_Series>
															</gmd:series>
															<gmd:otherCitationDetails>
																<xsl:for-each select="srccite/citeinfo/othercit">
																	<gco:CharacterString>
																		<xsl:sequence select="xs:string(.)"/>
																	</gco:CharacterString>
																</xsl:for-each>
															</gmd:otherCitationDetails>
														</gmd:CI_Citation>
													</gmd:sourceCitation>
													<gmd:sourceExtent>
														<gmd:EX_Extent>
															<xsl:for-each select="srctime">
																<xsl:variable name="var2470_srctime" as="node()" select="."/>
																<xsl:for-each select="timeinfo/sngdate">
																	<xsl:variable name="var2472_sngdate" as="node()" select="."/>
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:for-each select="caldate">
																					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																						<xsl:attribute name="gco:nilReason">
																							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																						</xsl:attribute>
																					</xsl:if>
																				</xsl:for-each>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id">
																						<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																					</xsl:attribute>
																					<xsl:for-each select="$var2470_srctime/srccurr">
																						<gml:description>
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</gml:description>
																					</xsl:for-each>
																					<xsl:variable name="var2604_map_select_caldate" as="xs:string*">
																						<xsl:for-each select="caldate">
																							<xsl:variable name="var2677_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																									<xsl:variable name="var2710_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var2709_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var2710_map_result_distinctvalues)">
																											<xsl:variable name="var2715_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2715_cond_result_endswith)">
																												<xsl:sequence select="$var2715_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2709_map_result_distinctvalues)">
																										<xsl:sequence select="xs:string(fn:string-join($var2709_map_result_distinctvalues, ' '))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var2677_cond_result_logicalor">
																								<xsl:variable name="var2678_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var2680_map_select_time" as="xs:string*">
																									<xsl:for-each select="$var2472_sngdate/time">
																										<xsl:variable name="var2707_result_vmf5_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf5_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var2706_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2707_result_vmf5_inputtoresult)) then (if (fn:contains($var2707_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var2706_cond_result_exists))">
																											<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var2680_map_select_time)">
																									<xsl:variable name="var2685_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var2685_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2685_cond_result_endswith)), 'Un'))">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2685_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2685_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2685_cond_result_endswith))))) then 'T' else ()))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2678_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2685_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2685_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2685_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2685_cond_result_endswith))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2483_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var2604_map_select_caldate)">
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var2609_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var2642_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var2641_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var2642_map_result_distinctvalues)">
																													<xsl:variable name="var2647_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2647_cond_result_endswith)">
																														<xsl:sequence select="$var2647_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2641_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var2641_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var2609_cond_result_logicalor">
																										<xsl:variable name="var2610_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var2612_map_select_time" as="xs:string*">
																											<xsl:for-each select="$var2472_sngdate/time">
																												<xsl:variable name="var2639_result_vmf5_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf5_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var2638_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2639_result_vmf5_inputtoresult)) then (if (fn:contains($var2639_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var2638_cond_result_exists))">
																													<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var2612_map_select_time)">
																											<xsl:variable name="var2617_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2617_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2617_cond_result_endswith)), 'Un'))">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2617_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2617_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2617_cond_result_endswith))))) then 'T' else ()))">
																														<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2610_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2617_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2617_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2617_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2617_cond_result_endswith))))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="caldate">
																									<xsl:variable name="var2657_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var2662_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var2661_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var2662_map_result_distinctvalues)">
																													<xsl:variable name="var2667_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2667_cond_result_endswith)">
																														<xsl:sequence select="$var2667_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2661_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var2661_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var2657_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var2478_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="$var2483_cond_result_exists">
																								<xsl:variable name="var2485_map_select_caldate" as="xs:string*">
																									<xsl:for-each select="caldate">
																										<xsl:variable name="var2557_cond_result_logicalor" as="xs:string?">
																											<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																												<xsl:variable name="var2590_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., '-')">
																																<xsl:if test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:variable name="var2589_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values($var2590_map_result_distinctvalues)">
																														<xsl:variable name="var2595_cond_result_endswith" as="xs:string?">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																			<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:variable>
																														<xsl:if test="fn:exists($var2595_cond_result_endswith)">
																															<xsl:sequence select="$var2595_cond_result_endswith"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2589_map_result_distinctvalues)">
																													<xsl:sequence select="xs:string(fn:string-join($var2589_map_result_distinctvalues, ' '))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:variable>
																										<xsl:for-each select="$var2557_cond_result_logicalor">
																											<xsl:variable name="var2558_cur_cond_result_logicalor" as="xs:string" select="."/>
																											<xsl:variable name="var2560_map_select_time" as="xs:string*">
																												<xsl:for-each select="$var2472_sngdate/time">
																													<xsl:variable name="var2587_result_vmf5_inputtoresult" as="xs:string?">
																														<xsl:call-template name="vmf:vmf5_inputtoresult">
																															<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																														</xsl:call-template>
																													</xsl:variable>
																													<xsl:variable name="var2586_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2587_result_vmf5_inputtoresult)) then (if (fn:contains($var2587_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																													<xsl:if test="not(fn:exists($var2586_cond_result_exists))">
																														<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:for-each select="fn:distinct-values($var2560_map_select_time)">
																												<xsl:variable name="var2565_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., ':')">
																															<xsl:if test="fn:ends-with(., ':')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2565_cond_result_endswith)">
																													<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2565_cond_result_endswith)), 'Un'))">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2565_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2565_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2565_cond_result_endswith))))) then 'T' else ()))">
																															<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2558_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2565_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2565_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2565_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2565_cond_result_endswith))))"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when test="fn:exists($var2485_map_select_caldate)">
																										<xsl:for-each select="caldate">
																											<xsl:variable name="var2489_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var2522_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var2521_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var2522_map_result_distinctvalues)">
																															<xsl:variable name="var2527_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var2527_cond_result_endswith)">
																																<xsl:sequence select="$var2527_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2521_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var2521_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var2489_cond_result_logicalor">
																												<xsl:variable name="var2490_cur_cond_result_logicalor" as="xs:string" select="."/>
																												<xsl:variable name="var2492_map_select_time" as="xs:string*">
																													<xsl:for-each select="$var2472_sngdate/time">
																														<xsl:variable name="var2519_result_vmf5_inputtoresult" as="xs:string?">
																															<xsl:call-template name="vmf:vmf5_inputtoresult">
																																<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																															</xsl:call-template>
																														</xsl:variable>
																														<xsl:variable name="var2518_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2519_result_vmf5_inputtoresult)) then (if (fn:contains($var2519_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																														<xsl:if test="not(fn:exists($var2518_cond_result_exists))">
																															<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:for-each select="fn:distinct-values($var2492_map_select_time)">
																													<xsl:variable name="var2497_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., ':')">
																																<xsl:if test="fn:ends-with(., ':')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2497_cond_result_endswith)">
																														<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2497_cond_result_endswith)), 'Un'))">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2497_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2497_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2497_cond_result_endswith))))) then 'T' else ()))">
																																<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2490_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2497_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2497_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2497_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2497_cond_result_endswith))))"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:for-each select="caldate">
																											<xsl:variable name="var2537_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var2542_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var2541_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var2542_map_result_distinctvalues)">
																															<xsl:variable name="var2547_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var2547_cond_result_endswith)">
																																<xsl:sequence select="$var2547_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2541_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var2541_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var2537_cond_result_logicalor">
																												<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="caldate">
																									<xsl:choose>
																										<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																											<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="''"/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var2478_cond_result_exists">
																						<gml:timePosition>
																							<xsl:for-each select="$var2472_sngdate/caldate">
																								<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																									</xsl:attribute>
																								</xsl:if>
																							</xsl:for-each>
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</gml:timePosition>
																					</xsl:for-each>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
															</xsl:for-each>
															<xsl:for-each-group select="srctime/timeinfo/mdattim/sngdate" group-by="grp:key197eca10(.)">
																<xsl:variable name="var2725_cur_result_groupby" as="item()+" select="current-group()"/>
																<gmd:temporalElement>
																	<gmd:EX_TemporalExtent>
																		<gmd:extent>
																			<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																				<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																					</xsl:attribute>
																				</xsl:if>
																			</xsl:for-each>
																			<gml:TimeInstant>
																				<xsl:attribute name="gml:id">
																					<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																				</xsl:attribute>
																				<xsl:for-each select="$var2344_srcinfo/srctime">
																					<xsl:variable name="var2730_srctime" as="node()" select="."/>
																					<xsl:for-each select="srccurr">
																						<xsl:if test="fn:exists($var2730_srctime/timeinfo/mdattim)">
																							<gml:description>
																								<xsl:sequence select="xs:string(xs:string(.))"/>
																							</gml:description>
																						</xsl:if>
																					</xsl:for-each>
																				</xsl:for-each>
																				<xsl:variable name="var2864_map_result_groupitems" as="xs:string*">
																					<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																						<xsl:variable name="var2937_cond_result_logicalor" as="xs:string?">
																							<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																								<xsl:variable name="var2970_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., '-')">
																												<xsl:if test="fn:ends-with(., '-')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:variable name="var2969_map_result_distinctvalues" as="xs:string*">
																									<xsl:for-each select="fn:distinct-values($var2970_map_result_distinctvalues)">
																										<xsl:variable name="var2975_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																													<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																															<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2975_cond_result_endswith)">
																											<xsl:sequence select="$var2975_cond_result_endswith"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2969_map_result_distinctvalues)">
																									<xsl:sequence select="xs:string(fn:string-join($var2969_map_result_distinctvalues, ' '))"/>
																								</xsl:if>
																							</xsl:if>
																						</xsl:variable>
																						<xsl:for-each select="$var2937_cond_result_logicalor">
																							<xsl:variable name="var2938_cur_cond_result_logicalor" as="xs:string" select="."/>
																							<xsl:variable name="var2940_map_result_groupitems" as="xs:string*">
																								<xsl:for-each select="$var2725_cur_result_groupby/time">
																									<xsl:variable name="var2967_result_vmf5_inputtoresult" as="xs:string?">
																										<xsl:call-template name="vmf:vmf5_inputtoresult">
																											<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																										</xsl:call-template>
																									</xsl:variable>
																									<xsl:variable name="var2966_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2967_result_vmf5_inputtoresult)) then (if (fn:contains($var2967_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																									<xsl:if test="not(fn:exists($var2966_cond_result_exists))">
																										<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:for-each select="fn:distinct-values($var2940_map_result_groupitems)">
																								<xsl:variable name="var2945_cond_result_endswith" as="xs:string?">
																									<xsl:choose>
																										<xsl:when test="fn:ends-with(., ':')">
																											<xsl:if test="fn:ends-with(., ':')">
																												<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																													<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="."/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:variable>
																								<xsl:if test="fn:exists($var2945_cond_result_endswith)">
																									<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2945_cond_result_endswith)), 'Un'))">
																										<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2945_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2945_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2945_cond_result_endswith))))) then 'T' else ()))">
																											<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2938_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2945_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2945_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2945_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2945_cond_result_endswith))))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:for-each>
																				</xsl:variable>
																				<xsl:variable name="var2743_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="fn:exists($var2864_map_result_groupitems)">
																							<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																								<xsl:variable name="var2869_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																										<xsl:variable name="var2902_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var2901_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var2902_map_result_distinctvalues)">
																												<xsl:variable name="var2907_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2907_cond_result_endswith)">
																													<xsl:sequence select="$var2907_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2901_map_result_distinctvalues)">
																											<xsl:sequence select="xs:string(fn:string-join($var2901_map_result_distinctvalues, ' '))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var2869_cond_result_logicalor">
																									<xsl:variable name="var2870_cur_cond_result_logicalor" as="xs:string" select="."/>
																									<xsl:variable name="var2872_map_result_groupitems" as="xs:string*">
																										<xsl:for-each select="$var2725_cur_result_groupby/time">
																											<xsl:variable name="var2899_result_vmf5_inputtoresult" as="xs:string?">
																												<xsl:call-template name="vmf:vmf5_inputtoresult">
																													<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																												</xsl:call-template>
																											</xsl:variable>
																											<xsl:variable name="var2898_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2899_result_vmf5_inputtoresult)) then (if (fn:contains($var2899_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																											<xsl:if test="not(fn:exists($var2898_cond_result_exists))">
																												<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:for-each select="fn:distinct-values($var2872_map_result_groupitems)">
																										<xsl:variable name="var2877_cond_result_endswith" as="xs:string?">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., ':')">
																													<xsl:if test="fn:ends-with(., ':')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2877_cond_result_endswith)">
																											<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2877_cond_result_endswith)), 'Un'))">
																												<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2877_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2877_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2877_cond_result_endswith))))) then 'T' else ()))">
																													<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2870_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2877_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2877_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2877_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2877_cond_result_endswith))))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																								<xsl:variable name="var2917_cond_result_logicalor" as="xs:string?">
																									<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																										<xsl:variable name="var2922_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., '-')">
																														<xsl:if test="fn:ends-with(., '-')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:variable name="var2921_map_result_distinctvalues" as="xs:string*">
																											<xsl:for-each select="fn:distinct-values($var2922_map_result_distinctvalues)">
																												<xsl:variable name="var2927_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2927_cond_result_endswith)">
																													<xsl:sequence select="$var2927_cond_result_endswith"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:if test="fn:exists($var2921_map_result_distinctvalues)">
																											<xsl:sequence select="xs:string(fn:string-join($var2921_map_result_distinctvalues, ' '))"/>
																										</xsl:if>
																									</xsl:if>
																								</xsl:variable>
																								<xsl:for-each select="$var2917_cond_result_logicalor">
																									<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:variable name="var2734_cond_result_exists" as="xs:string*">
																					<xsl:choose>
																						<xsl:when test="$var2743_cond_result_exists">
																							<xsl:variable name="var2745_map_result_groupitems" as="xs:string*">
																								<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																									<xsl:variable name="var2817_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var2850_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var2849_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var2850_map_result_distinctvalues)">
																													<xsl:variable name="var2855_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var2855_cond_result_endswith)">
																														<xsl:sequence select="$var2855_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2849_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var2849_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var2817_cond_result_logicalor">
																										<xsl:variable name="var2818_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var2820_map_result_groupitems" as="xs:string*">
																											<xsl:for-each select="$var2725_cur_result_groupby/time">
																												<xsl:variable name="var2847_result_vmf5_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf5_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var2846_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2847_result_vmf5_inputtoresult)) then (if (fn:contains($var2847_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var2846_cond_result_exists))">
																													<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var2820_map_result_groupitems)">
																											<xsl:variable name="var2825_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var2825_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2825_cond_result_endswith)), 'Un'))">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2825_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2825_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2825_cond_result_endswith))))) then 'T' else ()))">
																														<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2818_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2825_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2825_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2825_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2825_cond_result_endswith))))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:variable>
																							<xsl:choose>
																								<xsl:when test="fn:exists($var2745_map_result_groupitems)">
																									<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																										<xsl:variable name="var2749_cond_result_logicalor" as="xs:string?">
																											<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																												<xsl:variable name="var2782_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., '-')">
																																<xsl:if test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:variable name="var2781_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values($var2782_map_result_distinctvalues)">
																														<xsl:variable name="var2787_cond_result_endswith" as="xs:string?">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																			<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:variable>
																														<xsl:if test="fn:exists($var2787_cond_result_endswith)">
																															<xsl:sequence select="$var2787_cond_result_endswith"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2781_map_result_distinctvalues)">
																													<xsl:sequence select="xs:string(fn:string-join($var2781_map_result_distinctvalues, ' '))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:variable>
																										<xsl:for-each select="$var2749_cond_result_logicalor">
																											<xsl:variable name="var2750_cur_cond_result_logicalor" as="xs:string" select="."/>
																											<xsl:variable name="var2752_map_result_groupitems" as="xs:string*">
																												<xsl:for-each select="$var2725_cur_result_groupby/time">
																													<xsl:variable name="var2779_result_vmf5_inputtoresult" as="xs:string?">
																														<xsl:call-template name="vmf:vmf5_inputtoresult">
																															<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																														</xsl:call-template>
																													</xsl:variable>
																													<xsl:variable name="var2778_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var2779_result_vmf5_inputtoresult)) then (if (fn:contains($var2779_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																													<xsl:if test="not(fn:exists($var2778_cond_result_exists))">
																														<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:for-each select="fn:distinct-values($var2752_map_result_groupitems)">
																												<xsl:variable name="var2757_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., ':')">
																															<xsl:if test="fn:ends-with(., ':')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2757_cond_result_endswith)">
																													<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var2757_cond_result_endswith)), 'Un'))">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var2757_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2757_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2757_cond_result_endswith))))) then 'T' else ()))">
																															<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var2750_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var2757_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var2757_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var2757_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var2757_cond_result_endswith))))"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:when>
																								<xsl:otherwise>
																									<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																										<xsl:variable name="var2797_cond_result_logicalor" as="xs:string?">
																											<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																												<xsl:variable name="var2802_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., '-')">
																																<xsl:if test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:variable name="var2801_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values($var2802_map_result_distinctvalues)">
																														<xsl:variable name="var2807_cond_result_endswith" as="xs:string?">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																			<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:variable>
																														<xsl:if test="fn:exists($var2807_cond_result_endswith)">
																															<xsl:sequence select="$var2807_cond_result_endswith"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var2801_map_result_distinctvalues)">
																													<xsl:sequence select="xs:string(fn:string-join($var2801_map_result_distinctvalues, ' '))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:variable>
																										<xsl:for-each select="$var2797_cond_result_logicalor">
																											<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:otherwise>
																							</xsl:choose>
																						</xsl:when>
																						<xsl:otherwise>
																							<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																								<xsl:choose>
																									<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																										<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:sequence select="''"/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:for-each>
																						</xsl:otherwise>
																					</xsl:choose>
																				</xsl:variable>
																				<xsl:for-each select="$var2734_cond_result_exists">
																					<gml:timePosition>
																						<xsl:variable name="var2740_map_result_groupitems" as="xs:string*">
																							<xsl:for-each select="$var2725_cur_result_groupby/caldate">
																								<xsl:if test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																									<xsl:sequence select="'now'"/>
																								</xsl:if>
																							</xsl:for-each>
																						</xsl:variable>
																						<xsl:variable name="var2737_cond_result_exists" as="xs:string*" select="(if (fn:exists($var2740_map_result_groupitems)) then $var2740_map_result_groupitems else 'unknown')"/>
																						<xsl:for-each select="$var2737_cond_result_exists">
																							<xsl:attribute name="indeterminatePosition">
																								<xsl:sequence select="."/>
																							</xsl:attribute>
																						</xsl:for-each>
																						<xsl:sequence select="xs:string(xs:string(.))"/>
																					</gml:timePosition>
																				</xsl:for-each>
																			</gml:TimeInstant>
																		</gmd:extent>
																	</gmd:EX_TemporalExtent>
																</gmd:temporalElement>
															</xsl:for-each-group>
															<xsl:for-each select="srctime">
																<xsl:variable name="var2982_srctime" as="node()" select="."/>
																<xsl:for-each select="timeinfo/rngdates">
																	<xsl:variable name="var2984_rngdates" as="node()" select="."/>
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:for-each select="begdate">
																					<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished'))">
																						<xsl:attribute name="gco:nilReason">
																							<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(xs:string(.))))))"/>
																						</xsl:attribute>
																					</xsl:if>
																				</xsl:for-each>
																				<gml:TimePeriod>
																					<xsl:attribute name="gml:id">
																						<xsl:sequence select="xs:string(xs:ID('sourceTemporalExtent'))"/>
																					</xsl:attribute>
																					<xsl:for-each select="$var2982_srctime/srccurr">
																						<gml:description>
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</gml:description>
																					</xsl:for-each>
																					<xsl:variable name="var3116_map_select_begdate" as="xs:string*">
																						<xsl:for-each select="begdate">
																							<xsl:variable name="var3189_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																									<xsl:variable name="var3222_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3221_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3222_map_result_distinctvalues)">
																											<xsl:variable name="var3227_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3227_cond_result_endswith)">
																												<xsl:sequence select="$var3227_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3221_map_result_distinctvalues)">
																										<xsl:sequence select="xs:string(fn:string-join($var3221_map_result_distinctvalues, ' '))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3189_cond_result_logicalor">
																								<xsl:variable name="var3190_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3192_map_select_begtime" as="xs:string*">
																									<xsl:for-each select="$var2984_rngdates/begtime">
																										<xsl:variable name="var3219_result_vmf5_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf5_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3218_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3219_result_vmf5_inputtoresult)) then (if (fn:contains($var3219_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3218_cond_result_exists))">
																											<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3192_map_select_begtime)">
																									<xsl:variable name="var3197_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3197_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3197_cond_result_endswith)), 'Un'))">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3197_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3197_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3197_cond_result_endswith))))) then 'T' else ()))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3190_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3197_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3197_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3197_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3197_cond_result_endswith))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var2995_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3116_map_select_begdate)">
																								<xsl:for-each select="begdate">
																									<xsl:variable name="var3121_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var3154_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3153_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3154_map_result_distinctvalues)">
																													<xsl:variable name="var3159_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3159_cond_result_endswith)">
																														<xsl:sequence select="$var3159_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3153_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var3153_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3121_cond_result_logicalor">
																										<xsl:variable name="var3122_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3124_map_select_begtime" as="xs:string*">
																											<xsl:for-each select="$var2984_rngdates/begtime">
																												<xsl:variable name="var3151_result_vmf5_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf5_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3150_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3151_result_vmf5_inputtoresult)) then (if (fn:contains($var3151_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3150_cond_result_exists))">
																													<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3124_map_select_begtime)">
																											<xsl:variable name="var3129_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3129_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3129_cond_result_endswith)), 'Un'))">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3129_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3129_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3129_cond_result_endswith))))) then 'T' else ()))">
																														<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3122_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3129_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3129_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3129_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3129_cond_result_endswith))))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="begdate">
																									<xsl:variable name="var3169_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var3174_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3173_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3174_map_result_distinctvalues)">
																													<xsl:variable name="var3179_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3179_cond_result_endswith)">
																														<xsl:sequence select="$var3179_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3173_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var3173_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3169_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var2990_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="$var2995_cond_result_exists">
																								<xsl:variable name="var2997_map_select_begdate" as="xs:string*">
																									<xsl:for-each select="begdate">
																										<xsl:variable name="var3069_cond_result_logicalor" as="xs:string?">
																											<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																												<xsl:variable name="var3102_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., '-')">
																																<xsl:if test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:variable name="var3101_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values($var3102_map_result_distinctvalues)">
																														<xsl:variable name="var3107_cond_result_endswith" as="xs:string?">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																			<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:variable>
																														<xsl:if test="fn:exists($var3107_cond_result_endswith)">
																															<xsl:sequence select="$var3107_cond_result_endswith"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3101_map_result_distinctvalues)">
																													<xsl:sequence select="xs:string(fn:string-join($var3101_map_result_distinctvalues, ' '))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:variable>
																										<xsl:for-each select="$var3069_cond_result_logicalor">
																											<xsl:variable name="var3070_cur_cond_result_logicalor" as="xs:string" select="."/>
																											<xsl:variable name="var3072_map_select_begtime" as="xs:string*">
																												<xsl:for-each select="$var2984_rngdates/begtime">
																													<xsl:variable name="var3099_result_vmf5_inputtoresult" as="xs:string?">
																														<xsl:call-template name="vmf:vmf5_inputtoresult">
																															<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																														</xsl:call-template>
																													</xsl:variable>
																													<xsl:variable name="var3098_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3099_result_vmf5_inputtoresult)) then (if (fn:contains($var3099_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																													<xsl:if test="not(fn:exists($var3098_cond_result_exists))">
																														<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:for-each select="fn:distinct-values($var3072_map_select_begtime)">
																												<xsl:variable name="var3077_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., ':')">
																															<xsl:if test="fn:ends-with(., ':')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3077_cond_result_endswith)">
																													<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3077_cond_result_endswith)), 'Un'))">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3077_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3077_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3077_cond_result_endswith))))) then 'T' else ()))">
																															<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3070_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3077_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3077_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3077_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3077_cond_result_endswith))))"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when test="fn:exists($var2997_map_select_begdate)">
																										<xsl:for-each select="begdate">
																											<xsl:variable name="var3001_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var3034_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var3033_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var3034_map_result_distinctvalues)">
																															<xsl:variable name="var3039_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var3039_cond_result_endswith)">
																																<xsl:sequence select="$var3039_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3033_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var3033_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var3001_cond_result_logicalor">
																												<xsl:variable name="var3002_cur_cond_result_logicalor" as="xs:string" select="."/>
																												<xsl:variable name="var3004_map_select_begtime" as="xs:string*">
																													<xsl:for-each select="$var2984_rngdates/begtime">
																														<xsl:variable name="var3031_result_vmf5_inputtoresult" as="xs:string?">
																															<xsl:call-template name="vmf:vmf5_inputtoresult">
																																<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																															</xsl:call-template>
																														</xsl:variable>
																														<xsl:variable name="var3030_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3031_result_vmf5_inputtoresult)) then (if (fn:contains($var3031_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																														<xsl:if test="not(fn:exists($var3030_cond_result_exists))">
																															<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:for-each select="fn:distinct-values($var3004_map_select_begtime)">
																													<xsl:variable name="var3009_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., ':')">
																																<xsl:if test="fn:ends-with(., ':')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3009_cond_result_endswith)">
																														<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3009_cond_result_endswith)), 'Un'))">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3009_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3009_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3009_cond_result_endswith))))) then 'T' else ()))">
																																<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3002_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3009_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3009_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3009_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3009_cond_result_endswith))))"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:for-each select="begdate">
																											<xsl:variable name="var3049_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var3054_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var3053_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var3054_map_result_distinctvalues)">
																															<xsl:variable name="var3059_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var3059_cond_result_endswith)">
																																<xsl:sequence select="$var3059_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3053_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var3053_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var3049_cond_result_logicalor">
																												<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="begdate">
																									<xsl:choose>
																										<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																											<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="''"/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var2990_cond_result_exists">
																						<gml:beginPosition>
																							<xsl:for-each select="$var2984_rngdates/begdate">
																								<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																									</xsl:attribute>
																								</xsl:if>
																							</xsl:for-each>
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</gml:beginPosition>
																					</xsl:for-each>
																					<xsl:variable name="var3360_map_select_enddate" as="xs:string*">
																						<xsl:for-each select="enddate">
																							<xsl:variable name="var3433_cond_result_logicalor" as="xs:string?">
																								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																									<xsl:variable name="var3466_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																											<xsl:choose>
																												<xsl:when test="fn:ends-with(., '-')">
																													<xsl:if test="fn:ends-with(., '-')">
																														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:when>
																												<xsl:otherwise>
																													<xsl:sequence select="."/>
																												</xsl:otherwise>
																											</xsl:choose>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:variable name="var3465_map_result_distinctvalues" as="xs:string*">
																										<xsl:for-each select="fn:distinct-values($var3466_map_result_distinctvalues)">
																											<xsl:variable name="var3471_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3471_cond_result_endswith)">
																												<xsl:sequence select="$var3471_cond_result_endswith"/>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3465_map_result_distinctvalues)">
																										<xsl:sequence select="xs:string(fn:string-join($var3465_map_result_distinctvalues, ' '))"/>
																									</xsl:if>
																								</xsl:if>
																							</xsl:variable>
																							<xsl:for-each select="$var3433_cond_result_logicalor">
																								<xsl:variable name="var3434_cur_cond_result_logicalor" as="xs:string" select="."/>
																								<xsl:variable name="var3436_map_select_endtime" as="xs:string*">
																									<xsl:for-each select="$var2984_rngdates/endtime">
																										<xsl:variable name="var3463_result_vmf5_inputtoresult" as="xs:string?">
																											<xsl:call-template name="vmf:vmf5_inputtoresult">
																												<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																											</xsl:call-template>
																										</xsl:variable>
																										<xsl:variable name="var3462_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3463_result_vmf5_inputtoresult)) then (if (fn:contains($var3463_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																										<xsl:if test="not(fn:exists($var3462_cond_result_exists))">
																											<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																										</xsl:if>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:for-each select="fn:distinct-values($var3436_map_select_endtime)">
																									<xsl:variable name="var3441_cond_result_endswith" as="xs:string?">
																										<xsl:choose>
																											<xsl:when test="fn:ends-with(., ':')">
																												<xsl:if test="fn:ends-with(., ':')">
																													<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																														<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:when>
																											<xsl:otherwise>
																												<xsl:sequence select="."/>
																											</xsl:otherwise>
																										</xsl:choose>
																									</xsl:variable>
																									<xsl:if test="fn:exists($var3441_cond_result_endswith)">
																										<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3441_cond_result_endswith)), 'Un'))">
																											<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3441_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3441_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3441_cond_result_endswith))))) then 'T' else ()))">
																												<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3434_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3441_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3441_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3441_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3441_cond_result_endswith))))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:if>
																								</xsl:for-each>
																							</xsl:for-each>
																						</xsl:for-each>
																					</xsl:variable>
																					<xsl:variable name="var3239_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="fn:exists($var3360_map_select_enddate)">
																								<xsl:for-each select="enddate">
																									<xsl:variable name="var3365_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var3398_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3397_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3398_map_result_distinctvalues)">
																													<xsl:variable name="var3403_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3403_cond_result_endswith)">
																														<xsl:sequence select="$var3403_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3397_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var3397_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3365_cond_result_logicalor">
																										<xsl:variable name="var3366_cur_cond_result_logicalor" as="xs:string" select="."/>
																										<xsl:variable name="var3368_map_select_endtime" as="xs:string*">
																											<xsl:for-each select="$var2984_rngdates/endtime">
																												<xsl:variable name="var3395_result_vmf5_inputtoresult" as="xs:string?">
																													<xsl:call-template name="vmf:vmf5_inputtoresult">
																														<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																													</xsl:call-template>
																												</xsl:variable>
																												<xsl:variable name="var3394_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3395_result_vmf5_inputtoresult)) then (if (fn:contains($var3395_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																												<xsl:if test="not(fn:exists($var3394_cond_result_exists))">
																													<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:variable>
																										<xsl:for-each select="fn:distinct-values($var3368_map_select_endtime)">
																											<xsl:variable name="var3373_cond_result_endswith" as="xs:string?">
																												<xsl:choose>
																													<xsl:when test="fn:ends-with(., ':')">
																														<xsl:if test="fn:ends-with(., ':')">
																															<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:when>
																													<xsl:otherwise>
																														<xsl:sequence select="."/>
																													</xsl:otherwise>
																												</xsl:choose>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3373_cond_result_endswith)">
																												<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3373_cond_result_endswith)), 'Un'))">
																													<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3373_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3373_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3373_cond_result_endswith))))) then 'T' else ()))">
																														<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3366_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3373_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3373_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3373_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3373_cond_result_endswith))))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:if>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="enddate">
																									<xsl:variable name="var3413_cond_result_logicalor" as="xs:string?">
																										<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																											<xsl:variable name="var3418_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., '-')">
																															<xsl:if test="fn:ends-with(., '-')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:variable name="var3417_map_result_distinctvalues" as="xs:string*">
																												<xsl:for-each select="fn:distinct-values($var3418_map_result_distinctvalues)">
																													<xsl:variable name="var3423_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3423_cond_result_endswith)">
																														<xsl:sequence select="$var3423_cond_result_endswith"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:if test="fn:exists($var3417_map_result_distinctvalues)">
																												<xsl:sequence select="xs:string(fn:string-join($var3417_map_result_distinctvalues, ' '))"/>
																											</xsl:if>
																										</xsl:if>
																									</xsl:variable>
																									<xsl:for-each select="$var3413_cond_result_logicalor">
																										<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																									</xsl:for-each>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:variable name="var3234_cond_result_exists" as="xs:string*">
																						<xsl:choose>
																							<xsl:when test="$var3239_cond_result_exists">
																								<xsl:variable name="var3241_map_select_enddate" as="xs:string*">
																									<xsl:for-each select="enddate">
																										<xsl:variable name="var3313_cond_result_logicalor" as="xs:string?">
																											<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																												<xsl:variable name="var3346_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., '-')">
																																<xsl:if test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:variable name="var3345_map_result_distinctvalues" as="xs:string*">
																													<xsl:for-each select="fn:distinct-values($var3346_map_result_distinctvalues)">
																														<xsl:variable name="var3351_cond_result_endswith" as="xs:string?">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																	<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																			<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:variable>
																														<xsl:if test="fn:exists($var3351_cond_result_endswith)">
																															<xsl:sequence select="$var3351_cond_result_endswith"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3345_map_result_distinctvalues)">
																													<xsl:sequence select="xs:string(fn:string-join($var3345_map_result_distinctvalues, ' '))"/>
																												</xsl:if>
																											</xsl:if>
																										</xsl:variable>
																										<xsl:for-each select="$var3313_cond_result_logicalor">
																											<xsl:variable name="var3314_cur_cond_result_logicalor" as="xs:string" select="."/>
																											<xsl:variable name="var3316_map_select_endtime" as="xs:string*">
																												<xsl:for-each select="$var2984_rngdates/endtime">
																													<xsl:variable name="var3343_result_vmf5_inputtoresult" as="xs:string?">
																														<xsl:call-template name="vmf:vmf5_inputtoresult">
																															<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																														</xsl:call-template>
																													</xsl:variable>
																													<xsl:variable name="var3342_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3343_result_vmf5_inputtoresult)) then (if (fn:contains($var3343_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																													<xsl:if test="not(fn:exists($var3342_cond_result_exists))">
																														<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:variable>
																											<xsl:for-each select="fn:distinct-values($var3316_map_select_endtime)">
																												<xsl:variable name="var3321_cond_result_endswith" as="xs:string?">
																													<xsl:choose>
																														<xsl:when test="fn:ends-with(., ':')">
																															<xsl:if test="fn:ends-with(., ':')">
																																<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																	<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																</xsl:if>
																															</xsl:if>
																														</xsl:when>
																														<xsl:otherwise>
																															<xsl:sequence select="."/>
																														</xsl:otherwise>
																													</xsl:choose>
																												</xsl:variable>
																												<xsl:if test="fn:exists($var3321_cond_result_endswith)">
																													<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3321_cond_result_endswith)), 'Un'))">
																														<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3321_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3321_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3321_cond_result_endswith))))) then 'T' else ()))">
																															<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3314_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3321_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3321_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3321_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3321_cond_result_endswith))))"/>
																														</xsl:if>
																													</xsl:if>
																												</xsl:if>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:for-each>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when test="fn:exists($var3241_map_select_enddate)">
																										<xsl:for-each select="enddate">
																											<xsl:variable name="var3245_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var3278_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var3277_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var3278_map_result_distinctvalues)">
																															<xsl:variable name="var3283_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var3283_cond_result_endswith)">
																																<xsl:sequence select="$var3283_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3277_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var3277_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var3245_cond_result_logicalor">
																												<xsl:variable name="var3246_cur_cond_result_logicalor" as="xs:string" select="."/>
																												<xsl:variable name="var3248_map_select_endtime" as="xs:string*">
																													<xsl:for-each select="$var2984_rngdates/endtime">
																														<xsl:variable name="var3275_result_vmf5_inputtoresult" as="xs:string?">
																															<xsl:call-template name="vmf:vmf5_inputtoresult">
																																<xsl:with-param name="input" select="fn:upper-case(fn:string(.))"/>
																															</xsl:call-template>
																														</xsl:variable>
																														<xsl:variable name="var3274_cond_result_exists" as="xs:boolean?" select="(if (fn:exists($var3275_result_vmf5_inputtoresult)) then (if (fn:contains($var3275_result_vmf5_inputtoresult, 'unknown')) then fn:true() else ()) else ())"/>
																														<xsl:if test="not(fn:exists($var3274_cond_result_exists))">
																															<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:string(.), xs:double(xs:decimal(0)), xs:double(xs:decimal(3))), ':'), fn:substring(fn:string(.), xs:double(xs:decimal(3)), xs:double(xs:decimal(2)))), ':'), fn:substring(fn:string(.), xs:double('5'), xs:double(xs:decimal(2))))"/>
																														</xsl:if>
																													</xsl:for-each>
																												</xsl:variable>
																												<xsl:for-each select="fn:distinct-values($var3248_map_select_endtime)">
																													<xsl:variable name="var3253_cond_result_endswith" as="xs:string?">
																														<xsl:choose>
																															<xsl:when test="fn:ends-with(., ':')">
																																<xsl:if test="fn:ends-with(., ':')">
																																	<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ()))">
																																		<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(.)) - xs:decimal(1)))) else ())"/>
																																	</xsl:if>
																																</xsl:if>
																															</xsl:when>
																															<xsl:otherwise>
																																<xsl:sequence select="."/>
																															</xsl:otherwise>
																														</xsl:choose>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3253_cond_result_endswith)">
																														<xsl:if test="not(fn:contains(fn:normalize-space(fn:string($var3253_cond_result_endswith)), 'Un'))">
																															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(fn:string($var3253_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3253_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3253_cond_result_endswith))))) then 'T' else ()))">
																																<xsl:sequence select="fn:string(fn:concat(fn:concat(fn:normalize-space(fn:string(fn:normalize-space($var3246_cur_cond_result_logicalor))), (if (((('0' != fn:normalize-space(fn:string($var3253_cond_result_endswith))) and ('false' != fn:normalize-space(fn:string($var3253_cond_result_endswith)))) and fn:boolean(fn:normalize-space(fn:string($var3253_cond_result_endswith))))) then 'T' else ())), fn:normalize-space(fn:string($var3253_cond_result_endswith))))"/>
																															</xsl:if>
																														</xsl:if>
																													</xsl:if>
																												</xsl:for-each>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:for-each select="enddate">
																											<xsl:variable name="var3293_cond_result_logicalor" as="xs:string?">
																												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')))">
																													<xsl:variable name="var3298_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
																															<xsl:choose>
																																<xsl:when test="fn:ends-with(., '-')">
																																	<xsl:if test="fn:ends-with(., '-')">
																																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																																		</xsl:if>
																																	</xsl:if>
																																</xsl:when>
																																<xsl:otherwise>
																																	<xsl:sequence select="."/>
																																</xsl:otherwise>
																															</xsl:choose>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:variable name="var3297_map_result_distinctvalues" as="xs:string*">
																														<xsl:for-each select="fn:distinct-values($var3298_map_result_distinctvalues)">
																															<xsl:variable name="var3303_cond_result_endswith" as="xs:string?">
																																<xsl:choose>
																																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																																			</xsl:if>
																																		</xsl:if>
																																	</xsl:when>
																																	<xsl:otherwise>
																																		<xsl:sequence select="."/>
																																	</xsl:otherwise>
																																</xsl:choose>
																															</xsl:variable>
																															<xsl:if test="fn:exists($var3303_cond_result_endswith)">
																																<xsl:sequence select="$var3303_cond_result_endswith"/>
																															</xsl:if>
																														</xsl:for-each>
																													</xsl:variable>
																													<xsl:if test="fn:exists($var3297_map_result_distinctvalues)">
																														<xsl:sequence select="xs:string(fn:string-join($var3297_map_result_distinctvalues, ' '))"/>
																													</xsl:if>
																												</xsl:if>
																											</xsl:variable>
																											<xsl:for-each select="$var3293_cond_result_logicalor">
																												<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
																											</xsl:for-each>
																										</xsl:for-each>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:for-each select="enddate">
																									<xsl:choose>
																										<xsl:when test="fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')">
																											<xsl:sequence select="xs:string(fn:current-dateTime())"/>
																										</xsl:when>
																										<xsl:otherwise>
																											<xsl:sequence select="''"/>
																										</xsl:otherwise>
																									</xsl:choose>
																								</xsl:for-each>
																							</xsl:otherwise>
																						</xsl:choose>
																					</xsl:variable>
																					<xsl:for-each select="$var3234_cond_result_exists">
																						<gml:endPosition>
																							<xsl:for-each select="$var2984_rngdates/enddate">
																								<xsl:if test="fn:exists((if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ()))">
																									<xsl:attribute name="indeterminatePosition">
																										<xsl:sequence select="(if (fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:string(.)))), 'present')) then 'now' else ())"/>
																									</xsl:attribute>
																								</xsl:if>
																							</xsl:for-each>
																							<xsl:sequence select="xs:string(xs:string(.))"/>
																						</gml:endPosition>
																					</xsl:for-each>
																				</gml:TimePeriod>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
															</xsl:for-each>
														</gmd:EX_Extent>
													</gmd:sourceExtent>
												</gmd:LI_Source>
											</gmd:source>
										</xsl:for-each>
									</gmd:LI_Lineage>
								</gmd:lineage>
							</xsl:for-each>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var1_instance/metadata/metainfo">
				<xsl:variable name="var3478_metainfo" as="node()" select="."/>
				<xsl:for-each select="metac">
					<xsl:variable name="var3480_metac" as="node()" select="."/>
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var3478_metainfo/metuc">
										<xsl:attribute name="codeList">
											<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var3478_metainfo/metuc">
										<xsl:attribute name="codeListValue">
											<xsl:sequence select="xs:string(xs:anyURI('otherRestrictions'))"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var3478_metainfo/metuc">
										<xsl:attribute name="codeSpace">
											<xsl:sequence select="xs:string(xs:anyURI('008'))"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var3482_cond_result_exists" as="xs:string?">
									<xsl:choose>
										<xsl:when test="$var3478_metainfo/metuc">
											<xsl:variable name="var3487_map_select_metuc" as="xs:string*">
												<xsl:for-each select="$var3478_metainfo/metuc">
													<xsl:sequence select="xs:string(.)"/>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="fn:exists($var3487_map_select_metuc)">
												<xsl:sequence select="xs:string(fn:string-join($var3487_map_select_metuc, ' '))"/>
											</xsl:if>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var3482_cond_result_exists">
									<gco:CharacterString>
										<xsl:variable name="var3485_cond_result_exists" as="xs:string" select="(if (fn:exists($var3478_metainfo/metuc)) then ' Metadata Use Constraints: ' else ' ')"/>
										<xsl:sequence select="fn:normalize-space(fn:concat(fn:concat(fn:concat('Metadata Access Constraints: ', xs:string($var3480_metac)), $var3485_cond_result_exists), .))"/>
									</gco:CharacterString>
								</xsl:for-each>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
						<xsl:for-each select="$var3478_metainfo/metsi">
							<xsl:variable name="var3490_metsi" as="node()" select="."/>
							<gmd:MD_SecurityConstraints>
								<gmd:classification>
									<gmd:MD_ClassificationCode>
										<xsl:variable name="var3492_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="$var3490_metsi/metsc">
													<xsl:variable name="var3496_map_select_metsc" as="xs:string*">
														<xsl:for-each select="metsc">
															<xsl:variable name="var3499_result_vmf12_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf12_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var3499_result_vmf12_inputtoresult)">
																<xsl:sequence select="$var3499_result_vmf12_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var3496_map_select_metsc)">
														<xsl:sequence select="xs:string(fn:string-join($var3496_map_select_metsc, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var3492_cond_result_exists">
											<xsl:attribute name="codeList">
												<xsl:sequence select="xs:string(xs:anyURI(.))"/>
											</xsl:attribute>
										</xsl:for-each>
										<xsl:attribute name="codeListValue">
											<xsl:variable name="var3500_cond_result_exists" as="xs:string" select="(if (fn:exists(metsc)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode' else '')"/>
											<xsl:sequence select="xs:string(xs:anyURI($var3500_cond_result_exists))"/>
										</xsl:attribute>
										<xsl:variable name="var3501_cond_result_exists" as="xs:string?">
											<xsl:choose>
												<xsl:when test="$var3490_metsi/metsc">
													<xsl:variable name="var3505_map_select_metsc" as="xs:string*">
														<xsl:for-each select="metsc">
															<xsl:variable name="var3508_result_vmf13_inputtoresult" as="xs:string?">
																<xsl:call-template name="vmf:vmf13_inputtoresult">
																	<xsl:with-param name="input" select="fn:upper-case(fn:normalize-space(xs:string(xs:string(.))))"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:if test="fn:exists($var3508_result_vmf13_inputtoresult)">
																<xsl:sequence select="$var3508_result_vmf13_inputtoresult"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var3505_map_select_metsc)">
														<xsl:sequence select="xs:string(fn:string-join($var3505_map_select_metsc, ' '))"/>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="''"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:for-each select="$var3501_cond_result_exists">
											<xsl:attribute name="codeSpace">
												<xsl:sequence select="xs:string(xs:anyURI(.))"/>
											</xsl:attribute>
										</xsl:for-each>
									</gmd:MD_ClassificationCode>
								</gmd:classification>
								<gmd:classificationSystem>
									<xsl:for-each select="metscs">
										<gco:CharacterString>
											<xsl:sequence select="xs:string(.)"/>
										</gco:CharacterString>
									</xsl:for-each>
								</gmd:classificationSystem>
							</gmd:MD_SecurityConstraints>
						</xsl:for-each>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason">
							<xsl:sequence select="xs:string(xs:string('Unknown'))"/>
						</xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<xsl:for-each select="$var1_instance/metadata/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:if test="(fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unpublished'))">
								<xsl:attribute name="gco:nilReason">
									<xsl:sequence select="xs:string(xs:string(fn:lower-case(fn:normalize-space(xs:string(.)))))"/>
								</xsl:attribute>
							</xsl:if>
							<xsl:variable name="var3514_cond_result_logicalor" as="xs:string?">
								<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'present')))">
									<xsl:variable name="var3519_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(.))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(.))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(.))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(.))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
											<xsl:choose>
												<xsl:when test="fn:ends-with(., '-')">
													<xsl:if test="fn:ends-with(., '-')">
														<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
															<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
														</xsl:if>
													</xsl:if>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="."/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var3518_map_result_distinctvalues" as="xs:string*">
										<xsl:for-each select="fn:distinct-values($var3519_map_result_distinctvalues)">
											<xsl:variable name="var3524_cond_result_endswith" as="xs:string?">
												<xsl:choose>
													<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
														<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
															<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
															</xsl:if>
														</xsl:if>
													</xsl:when>
													<xsl:otherwise>
														<xsl:sequence select="."/>
													</xsl:otherwise>
												</xsl:choose>
											</xsl:variable>
											<xsl:if test="fn:exists($var3524_cond_result_endswith)">
												<xsl:sequence select="$var3524_cond_result_endswith"/>
											</xsl:if>
										</xsl:for-each>
									</xsl:variable>
									<xsl:if test="fn:exists($var3518_map_result_distinctvalues)">
										<xsl:sequence select="xs:string(fn:string-join($var3518_map_result_distinctvalues, ' '))"/>
									</xsl:if>
								</xsl:if>
							</xsl:variable>
							<xsl:for-each select="$var3514_cond_result_logicalor">
								<gco:Date>
									<xsl:sequence select="xs:string(xs:string(fn:string(fn:normalize-space(.))))"/>
								</gco:Date>
							</xsl:for-each>
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var1_instance/metadata/metainfo">
							<xsl:variable name="var3531_metainfo" as="node()" select="."/>
							<xsl:for-each select="metstdn">
								<xsl:variable name="var3533_metstdn" as="node()" select="."/>
								<xsl:for-each select="$var3531_metainfo/metstdv">
									<xsl:variable name="var3535_metstdv" as="node()" select="."/>
									<xsl:variable name="var3541_map_select_metadata" as="xs:string*">
										<xsl:for-each select="$var1_instance/metadata/metainfo/metrd">
											<xsl:variable name="var3545_cond_result_logicalor" as="xs:string?">
												<xsl:if test="not(((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'present')))">
													<xsl:variable name="var3550_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values((if (((fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'unknown') or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'unpublished')) or fn:contains(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), 'present'))) then () else fn:concat(fn:concat(fn:concat(fn:concat(fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), xs:double(xs:decimal(0)), xs:double(xs:decimal(5))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), xs:double(xs:decimal(5)), xs:double(xs:decimal(2)))), '-'), fn:substring(fn:lower-case(fn:normalize-space(xs:string(xs:token(.)))), xs:double(xs:decimal(7)), xs:double(xs:decimal(2))))))">
															<xsl:choose>
																<xsl:when test="fn:ends-with(., '-')">
																	<xsl:if test="fn:ends-with(., '-')">
																		<xsl:if test="fn:exists((if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ()))">
																			<xsl:sequence select="(if (((('0' != .) and ('false' != .)) and fn:boolean(.))) then fn:substring(., xs:double(xs:decimal(0)), xs:double(fn:string-length(.))) else ())"/>
																		</xsl:if>
																	</xsl:if>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:sequence select="."/>
																</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
													</xsl:variable>
													<xsl:variable name="var3549_map_result_distinctvalues" as="xs:string*">
														<xsl:for-each select="fn:distinct-values($var3550_map_result_distinctvalues)">
															<xsl:variable name="var3555_cond_result_endswith" as="xs:string?">
																<xsl:choose>
																	<xsl:when test="fn:ends-with(fn:normalize-space(.), '-')">
																		<xsl:if test="fn:ends-with(fn:normalize-space(.), '-')">
																			<xsl:if test="fn:exists((if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ()))">
																				<xsl:sequence select="(if (((('0' != fn:normalize-space(.)) and ('false' != fn:normalize-space(.))) and fn:boolean(fn:normalize-space(.)))) then fn:substring(fn:normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(fn:string-length(fn:normalize-space(.))) - xs:decimal(0)))) else ())"/>
																			</xsl:if>
																		</xsl:if>
																	</xsl:when>
																	<xsl:otherwise>
																		<xsl:sequence select="."/>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:variable>
															<xsl:if test="fn:exists($var3555_cond_result_endswith)">
																<xsl:sequence select="$var3555_cond_result_endswith"/>
															</xsl:if>
														</xsl:for-each>
													</xsl:variable>
													<xsl:if test="fn:exists($var3549_map_result_distinctvalues)">
														<xsl:sequence select="xs:string(fn:string-join($var3549_map_result_distinctvalues, ' '))"/>
													</xsl:if>
												</xsl:if>
											</xsl:variable>
											<xsl:for-each select="$var3545_cond_result_logicalor">
												<xsl:sequence select="fn:string(fn:normalize-space(.))"/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:variable>
									<xsl:variable name="var3537_cond_result_exists" as="xs:string*" select="(if (fn:exists($var3541_map_select_metadata)) then $var3541_map_select_metadata else ' ')"/>
									<xsl:for-each select="$var3537_cond_result_exists">
										<gco:CharacterString>
											<xsl:variable name="var3540_cond_result_exists" as="xs:string" select="(if (fn:exists($var1_instance/metadata/metainfo/metrd)) then ' Metadata Review Date: ' else ' ')"/>
											<xsl:sequence select="fn:normalize-space(fn:string(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('This metadata was automatically generated from the ', xs:string(xs:string($var3533_metstdn))), 'standard version '), xs:string($var3535_metstdv)), '. '), $var3540_cond_result_exists), .)))"/>
										</gco:CharacterString>
									</xsl:for-each>
								</xsl:for-each>
							</xsl:for-each>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:individualName>
								<xsl:variable name="var3565_map_select_metadata" as="xs:string*">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var3562_cond_result_exists" as="xs:string*">
									<xsl:choose>
										<xsl:when test="fn:exists($var3565_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntper">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var3562_cond_result_exists">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(.)"/>
									</gco:CharacterString>
								</xsl:for-each>
							</gmd:individualName>
							<gmd:organisationName>
								<xsl:variable name="var3576_map_select_metadata" as="xs:string*">
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
										<xsl:sequence select="xs:string(.)"/>
									</xsl:for-each>
								</xsl:variable>
								<xsl:variable name="var3573_cond_result_exists" as="xs:string*">
									<xsl:choose>
										<xsl:when test="fn:exists($var3576_map_select_metadata)">
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntperp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntorgp/cntorg">
												<xsl:sequence select="xs:string(.)"/>
											</xsl:for-each>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:for-each select="$var3573_cond_result_exists">
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(.)"/>
									</gco:CharacterString>
								</xsl:for-each>
							</gmd:organisationName>
							<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntpos">
								<gmd:positionName>
									<gco:CharacterString>
										<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
									</gco:CharacterString>
								</gmd:positionName>
							</xsl:for-each>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:phone>
										<gmd:CI_Telephone>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntvoice" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var3588_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:voice>
													<gco:CharacterString>
														<xsl:sequence select="$var3588_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:voice>
											</xsl:for-each-group>
											<xsl:for-each-group select="$var1_instance/metadata/metainfo/metc/cntinfo/cntfax" group-by="fn:normalize-space(xs:string(.))">
												<xsl:variable name="var3592_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
												<gmd:facsimile>
													<gco:CharacterString>
														<xsl:sequence select="$var3592_cur_result_groupby"/>
													</gco:CharacterString>
												</gmd:facsimile>
											</xsl:for-each-group>
										</gmd:CI_Telephone>
									</gmd:phone>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo">
										<xsl:variable name="var3594_cntinfo" as="node()" select="."/>
										<xsl:for-each select="cntaddr">
											<gmd:address>
												<gmd:CI_Address>
													<xsl:for-each-group select="address" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var3600_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:deliveryPoint>
															<gco:CharacterString>
																<xsl:sequence select="$var3600_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:deliveryPoint>
													</xsl:for-each-group>
													<xsl:for-each select="city">
														<gmd:city>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:city>
													</xsl:for-each>
													<xsl:for-each select="state">
														<gmd:administrativeArea>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:administrativeArea>
													</xsl:for-each>
													<xsl:for-each select="postal">
														<gmd:postalCode>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:postalCode>
													</xsl:for-each>
													<xsl:for-each select="country">
														<gmd:country>
															<gco:CharacterString>
																<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
															</gco:CharacterString>
														</gmd:country>
													</xsl:for-each>
													<xsl:for-each-group select="$var3594_cntinfo/cntemail" group-by="fn:normalize-space(xs:string(.))">
														<xsl:variable name="var3612_cur_result_groupby" as="xs:string" select="current-grouping-key()"/>
														<gmd:electronicMailAddress>
															<gco:CharacterString>
																<xsl:sequence select="$var3612_cur_result_groupby"/>
															</gco:CharacterString>
														</gmd:electronicMailAddress>
													</xsl:for-each-group>
												</gmd:CI_Address>
											</gmd:address>
										</xsl:for-each>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/hours">
										<gmd:hoursOfService>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:hoursOfService>
									</xsl:for-each>
									<xsl:for-each select="$var1_instance/metadata/metainfo/metc/cntinfo/cntinst">
										<gmd:contactInstructions>
											<gco:CharacterString>
												<xsl:sequence select="fn:normalize-space(xs:string(.))"/>
											</gco:CharacterString>
										</gmd:contactInstructions>
									</xsl:for-each>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode>
									<xsl:attribute name="codeList">
										<xsl:sequence select="xs:string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:sequence select="xs:string(xs:anyURI('custodian'))"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:sequence select="xs:string(xs:anyURI('002'))"/>
									</xsl:attribute>
									<xsl:sequence select="'custodian'"/>
								</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmi:MI_Metadata>
	</xsl:template>
</xsl:stylesheet>
